import{j as jsxRuntimeExports}from"./jsx-runtime.mvtouYz0.js";import{u,r as reactExports}from"./index.DcciWILN.js";import{c as cn,h as Slot}from"./SafeIcon.CAGsavDo.js";import{L as Label}from"./label.BFF1cpbq.js";var isCheckBoxInput=element=>element.type==="checkbox",isDateObject=value=>value instanceof Date,isNullOrUndefined=value=>value==null;const isObjectType=value=>typeof value=="object";var isObject$1=value=>!isNullOrUndefined(value)&&!Array.isArray(value)&&isObjectType(value)&&!isDateObject(value),getEventValue=event=>isObject$1(event)&&event.target?isCheckBoxInput(event.target)?event.target.checked:event.target.value:event,getNodeParentName=name=>name.substring(0,name.search(/\.\d+(\.|$)/))||name,isNameInFieldArray=(names,name)=>names.has(getNodeParentName(name)),isPlainObject$1=tempObject=>{const prototypeCopy=tempObject.constructor&&tempObject.constructor.prototype;return isObject$1(prototypeCopy)&&prototypeCopy.hasOwnProperty("isPrototypeOf")},isWeb=typeof window<"u"&&typeof window.HTMLElement<"u"&&typeof document<"u";function cloneObject(data){let copy;const isArray=Array.isArray(data),isFileListInstance=typeof FileList<"u"?data instanceof FileList:!1;if(data instanceof Date)copy=new Date(data);else if(!(isWeb&&(data instanceof Blob||isFileListInstance))&&(isArray||isObject$1(data)))if(copy=isArray?[]:Object.create(Object.getPrototypeOf(data)),!isArray&&!isPlainObject$1(data))copy=data;else for(const key in data)data.hasOwnProperty(key)&&(copy[key]=cloneObject(data[key]));else return data;return copy}var isKey=value=>/^\w*$/.test(value),isUndefined=val=>val===void 0,compact=value=>Array.isArray(value)?value.filter(Boolean):[],stringToPath=input=>compact(input.replace(/["|']|\]/g,"").split(/\.|\[/)),get=(object2,path,defaultValue)=>{if(!path||!isObject$1(object2))return defaultValue;const result=(isKey(path)?[path]:stringToPath(path)).reduce((result2,key)=>isNullOrUndefined(result2)?result2:result2[key],object2);return isUndefined(result)||result===object2?isUndefined(object2[path])?defaultValue:object2[path]:result},isBoolean=value=>typeof value=="boolean",set=(object2,path,value)=>{let index=-1;const tempPath=isKey(path)?[path]:stringToPath(path),length=tempPath.length,lastIndex=length-1;for(;++index<length;){const key=tempPath[index];let newValue=value;if(index!==lastIndex){const objValue=object2[key];newValue=isObject$1(objValue)||Array.isArray(objValue)?objValue:isNaN(+tempPath[index+1])?{}:[]}if(key==="__proto__"||key==="constructor"||key==="prototype")return;object2[key]=newValue,object2=object2[key]}};const EVENTS={BLUR:"blur",FOCUS_OUT:"focusout",CHANGE:"change"},VALIDATION_MODE={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},INPUT_VALIDATION_RULES={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"},HookFormContext=u.createContext(null);HookFormContext.displayName="HookFormContext";const useFormContext=()=>u.useContext(HookFormContext),FormProvider=props=>{const{children,...data}=props;return u.createElement(HookFormContext.Provider,{value:data},children)};var getProxyFormState=(formState,control,localProxyFormState,isRoot=!0)=>{const result={defaultValues:control._defaultValues};for(const key in formState)Object.defineProperty(result,key,{get:()=>{const _key=key;return control._proxyFormState[_key]!==VALIDATION_MODE.all&&(control._proxyFormState[_key]=!isRoot||VALIDATION_MODE.all),localProxyFormState&&(localProxyFormState[_key]=!0),formState[_key]}});return result};const useIsomorphicLayoutEffect=typeof window<"u"?u.useLayoutEffect:u.useEffect;function useFormState(props){const methods=useFormContext(),{control=methods.control,disabled,name,exact}=props||{},[formState,updateFormState]=u.useState(control._formState),_localProxyFormState=u.useRef({isDirty:!1,isLoading:!1,dirtyFields:!1,touchedFields:!1,validatingFields:!1,isValidating:!1,isValid:!1,errors:!1});return useIsomorphicLayoutEffect(()=>control._subscribe({name,formState:_localProxyFormState.current,exact,callback:formState2=>{!disabled&&updateFormState({...control._formState,...formState2})}}),[name,disabled,exact]),u.useEffect(()=>{_localProxyFormState.current.isValid&&control._setValid(!0)},[control]),u.useMemo(()=>getProxyFormState(formState,control,_localProxyFormState.current,!1),[formState,control])}var isString=value=>typeof value=="string",generateWatchOutput=(names,_names,formValues,isGlobal,defaultValue)=>isString(names)?(isGlobal&&_names.watch.add(names),get(formValues,names,defaultValue)):Array.isArray(names)?names.map(fieldName=>(isGlobal&&_names.watch.add(fieldName),get(formValues,fieldName))):(isGlobal&&(_names.watchAll=!0),formValues),isPrimitive=value=>isNullOrUndefined(value)||!isObjectType(value);function deepEqual(object1,object2,_internal_visited=new WeakSet){if(isPrimitive(object1)||isPrimitive(object2))return Object.is(object1,object2);if(isDateObject(object1)&&isDateObject(object2))return object1.getTime()===object2.getTime();const keys1=Object.keys(object1),keys2=Object.keys(object2);if(keys1.length!==keys2.length)return!1;if(_internal_visited.has(object1)||_internal_visited.has(object2))return!0;_internal_visited.add(object1),_internal_visited.add(object2);for(const key of keys1){const val1=object1[key];if(!keys2.includes(key))return!1;if(key!=="ref"){const val2=object2[key];if(isDateObject(val1)&&isDateObject(val2)||isObject$1(val1)&&isObject$1(val2)||Array.isArray(val1)&&Array.isArray(val2)?!deepEqual(val1,val2,_internal_visited):!Object.is(val1,val2))return!1}}return!0}function useWatch(props){const methods=useFormContext(),{control=methods.control,name,defaultValue,disabled,exact,compute}=props||{},_defaultValue=u.useRef(defaultValue),_compute=u.useRef(compute),_computeFormValues=u.useRef(void 0),_prevControl=u.useRef(control),_prevName=u.useRef(name);_compute.current=compute;const[value,updateValue]=u.useState(()=>{const defaultValue2=control._getWatch(name,_defaultValue.current);return _compute.current?_compute.current(defaultValue2):defaultValue2}),getCurrentOutput=u.useCallback(values=>{const formValues=generateWatchOutput(name,control._names,values||control._formValues,!1,_defaultValue.current);return _compute.current?_compute.current(formValues):formValues},[control._formValues,control._names,name]),refreshValue=u.useCallback(values=>{if(!disabled){const formValues=generateWatchOutput(name,control._names,values||control._formValues,!1,_defaultValue.current);if(_compute.current){const computedFormValues=_compute.current(formValues);deepEqual(computedFormValues,_computeFormValues.current)||(updateValue(computedFormValues),_computeFormValues.current=computedFormValues)}else updateValue(formValues)}},[control._formValues,control._names,disabled,name]);useIsomorphicLayoutEffect(()=>((_prevControl.current!==control||!deepEqual(_prevName.current,name))&&(_prevControl.current=control,_prevName.current=name,refreshValue()),control._subscribe({name,formState:{values:!0},exact,callback:formState=>{refreshValue(formState.values)}})),[control,exact,name,refreshValue]),u.useEffect(()=>control._removeUnmounted());const controlChanged=_prevControl.current!==control,prevName=_prevName.current,computedOutput=u.useMemo(()=>{if(disabled)return null;const nameChanged=!controlChanged&&!deepEqual(prevName,name);return controlChanged||nameChanged?getCurrentOutput():null},[disabled,controlChanged,name,prevName,getCurrentOutput]);return computedOutput!==null?computedOutput:value}function useController(props){const methods=useFormContext(),{name,disabled,control=methods.control,shouldUnregister,defaultValue,exact=!0}=props,isArrayField=isNameInFieldArray(control._names.array,name),defaultValueMemo=u.useMemo(()=>get(control._formValues,name,get(control._defaultValues,name,defaultValue)),[control,name,defaultValue]),value=useWatch({control,name,defaultValue:defaultValueMemo,exact}),formState=useFormState({control,name,exact}),_props=u.useRef(props),_previousNameRef=u.useRef(void 0),_registerProps=u.useRef(control.register(name,{...props.rules,value,...isBoolean(props.disabled)?{disabled:props.disabled}:{}}));_props.current=props;const fieldState=u.useMemo(()=>Object.defineProperties({},{invalid:{enumerable:!0,get:()=>!!get(formState.errors,name)},isDirty:{enumerable:!0,get:()=>!!get(formState.dirtyFields,name)},isTouched:{enumerable:!0,get:()=>!!get(formState.touchedFields,name)},isValidating:{enumerable:!0,get:()=>!!get(formState.validatingFields,name)},error:{enumerable:!0,get:()=>get(formState.errors,name)}}),[formState,name]),onChange=u.useCallback(event=>_registerProps.current.onChange({target:{value:getEventValue(event),name},type:EVENTS.CHANGE}),[name]),onBlur=u.useCallback(()=>_registerProps.current.onBlur({target:{value:get(control._formValues,name),name},type:EVENTS.BLUR}),[name,control._formValues]),ref=u.useCallback(elm=>{const field2=get(control._fields,name);field2&&elm&&(field2._f.ref={focus:()=>elm.focus&&elm.focus(),select:()=>elm.select&&elm.select(),setCustomValidity:message=>elm.setCustomValidity(message),reportValidity:()=>elm.reportValidity()})},[control._fields,name]),field=u.useMemo(()=>({name,value,...isBoolean(disabled)||formState.disabled?{disabled:formState.disabled||disabled}:{},onChange,onBlur,ref}),[name,disabled,formState.disabled,onChange,onBlur,ref,value]);return u.useEffect(()=>{const _shouldUnregisterField=control._options.shouldUnregister||shouldUnregister,previousName=_previousNameRef.current;previousName&&previousName!==name&&!isArrayField&&control.unregister(previousName),control.register(name,{..._props.current.rules,...isBoolean(_props.current.disabled)?{disabled:_props.current.disabled}:{}});const updateMounted=(name2,value2)=>{const field2=get(control._fields,name2);field2&&field2._f&&(field2._f.mount=value2)};if(updateMounted(name,!0),_shouldUnregisterField){const value2=cloneObject(get(control._options.defaultValues,name,_props.current.defaultValue));set(control._defaultValues,name,value2),isUndefined(get(control._formValues,name))&&set(control._formValues,name,value2)}return!isArrayField&&control.register(name),_previousNameRef.current=name,()=>{(isArrayField?_shouldUnregisterField&&!control._state.action:_shouldUnregisterField)?control.unregister(name):updateMounted(name,!1)}},[name,control,isArrayField,shouldUnregister]),u.useEffect(()=>{control._setDisabledField({disabled,name})},[disabled,name,control]),u.useMemo(()=>({field,formState,fieldState}),[field,formState,fieldState])}const Controller=props=>props.render(useController(props));var appendErrors=(name,validateAllFieldCriteria,errors,type,message)=>validateAllFieldCriteria?{...errors[name],types:{...errors[name]&&errors[name].types?errors[name].types:{},[type]:message||!0}}:{},convertToArrayPayload=value=>Array.isArray(value)?value:[value],createSubject=()=>{let _observers=[];return{get observers(){return _observers},next:value=>{for(const observer of _observers)observer.next&&observer.next(value)},subscribe:observer=>(_observers.push(observer),{unsubscribe:()=>{_observers=_observers.filter(o2=>o2!==observer)}}),unsubscribe:()=>{_observers=[]}}};function extractFormValues(fieldsState,formValues){const values={};for(const key in fieldsState)if(fieldsState.hasOwnProperty(key)){const fieldState=fieldsState[key],fieldValue=formValues[key];if(fieldState&&isObject$1(fieldState)&&fieldValue){const nestedFieldsState=extractFormValues(fieldState,fieldValue);isObject$1(nestedFieldsState)&&(values[key]=nestedFieldsState)}else fieldsState[key]&&(values[key]=fieldValue)}return values}var isEmptyObject=value=>isObject$1(value)&&!Object.keys(value).length,isFileInput=element=>element.type==="file",isFunction=value=>typeof value=="function",isHTMLElement=value=>{if(!isWeb)return!1;const owner=value?value.ownerDocument:0;return value instanceof(owner&&owner.defaultView?owner.defaultView.HTMLElement:HTMLElement)},isMultipleSelect=element=>element.type==="select-multiple",isRadioInput=element=>element.type==="radio",isRadioOrCheckbox=ref=>isRadioInput(ref)||isCheckBoxInput(ref),live=ref=>isHTMLElement(ref)&&ref.isConnected;function baseGet(object2,updatePath){const length=updatePath.slice(0,-1).length;let index=0;for(;index<length;)object2=isUndefined(object2)?index++:object2[updatePath[index++]];return object2}function isEmptyArray(obj){for(const key in obj)if(obj.hasOwnProperty(key)&&!isUndefined(obj[key]))return!1;return!0}function unset(object2,path){const paths=Array.isArray(path)?path:isKey(path)?[path]:stringToPath(path),childObject=paths.length===1?object2:baseGet(object2,paths),index=paths.length-1,key=paths[index];return childObject&&delete childObject[key],index!==0&&(isObject$1(childObject)&&isEmptyObject(childObject)||Array.isArray(childObject)&&isEmptyArray(childObject))&&unset(object2,paths.slice(0,-1)),object2}var objectHasFunction=data=>{for(const key in data)if(isFunction(data[key]))return!0;return!1};function isTraversable(value){return Array.isArray(value)||isObject$1(value)&&!objectHasFunction(value)}function markFieldsDirty(data,fields={}){for(const key in data){const value=data[key];isTraversable(value)?(fields[key]=Array.isArray(value)?[]:{},markFieldsDirty(value,fields[key])):isUndefined(value)||(fields[key]=!0)}return fields}function getDirtyFields(data,formValues,dirtyFieldsFromValues){dirtyFieldsFromValues||(dirtyFieldsFromValues=markFieldsDirty(formValues));for(const key in data){const value=data[key];if(isTraversable(value))isUndefined(formValues)||isPrimitive(dirtyFieldsFromValues[key])?dirtyFieldsFromValues[key]=markFieldsDirty(value,Array.isArray(value)?[]:{}):getDirtyFields(value,isNullOrUndefined(formValues)?{}:formValues[key],dirtyFieldsFromValues[key]);else{const formValue=formValues[key];dirtyFieldsFromValues[key]=!deepEqual(value,formValue)}}return dirtyFieldsFromValues}const defaultResult={value:!1,isValid:!1},validResult={value:!0,isValid:!0};var getCheckboxValue=options=>{if(Array.isArray(options)){if(options.length>1){const values=options.filter(option=>option&&option.checked&&!option.disabled).map(option=>option.value);return{value:values,isValid:!!values.length}}return options[0].checked&&!options[0].disabled?options[0].attributes&&!isUndefined(options[0].attributes.value)?isUndefined(options[0].value)||options[0].value===""?validResult:{value:options[0].value,isValid:!0}:validResult:defaultResult}return defaultResult},getFieldValueAs=(value,{valueAsNumber,valueAsDate,setValueAs})=>isUndefined(value)?value:valueAsNumber?value===""?NaN:value&&+value:valueAsDate&&isString(value)?new Date(value):setValueAs?setValueAs(value):value;const defaultReturn={isValid:!1,value:null};var getRadioValue=options=>Array.isArray(options)?options.reduce((previous,option)=>option&&option.checked&&!option.disabled?{isValid:!0,value:option.value}:previous,defaultReturn):defaultReturn;function getFieldValue(_f){const ref=_f.ref;return isFileInput(ref)?ref.files:isRadioInput(ref)?getRadioValue(_f.refs).value:isMultipleSelect(ref)?[...ref.selectedOptions].map(({value})=>value):isCheckBoxInput(ref)?getCheckboxValue(_f.refs).value:getFieldValueAs(isUndefined(ref.value)?_f.ref.value:ref.value,_f)}var getResolverOptions=(fieldsNames,_fields,criteriaMode,shouldUseNativeValidation)=>{const fields={};for(const name of fieldsNames){const field=get(_fields,name);field&&set(fields,name,field._f)}return{criteriaMode,names:[...fieldsNames],fields,shouldUseNativeValidation}},isRegex=value=>value instanceof RegExp,getRuleValue=rule=>isUndefined(rule)?rule:isRegex(rule)?rule.source:isObject$1(rule)?isRegex(rule.value)?rule.value.source:rule.value:rule,getValidationModes=mode=>({isOnSubmit:!mode||mode===VALIDATION_MODE.onSubmit,isOnBlur:mode===VALIDATION_MODE.onBlur,isOnChange:mode===VALIDATION_MODE.onChange,isOnAll:mode===VALIDATION_MODE.all,isOnTouch:mode===VALIDATION_MODE.onTouched});const ASYNC_FUNCTION="AsyncFunction";var hasPromiseValidation=fieldReference=>!!fieldReference&&!!fieldReference.validate&&!!(isFunction(fieldReference.validate)&&fieldReference.validate.constructor.name===ASYNC_FUNCTION||isObject$1(fieldReference.validate)&&Object.values(fieldReference.validate).find(validateFunction=>validateFunction.constructor.name===ASYNC_FUNCTION)),hasValidation=options=>options.mount&&(options.required||options.min||options.max||options.maxLength||options.minLength||options.pattern||options.validate),isWatched=(name,_names,isBlurEvent)=>!isBlurEvent&&(_names.watchAll||_names.watch.has(name)||[..._names.watch].some(watchName=>name.startsWith(watchName)&&/^\.\w+/.test(name.slice(watchName.length))));const iterateFieldsByAction=(fields,action,fieldsNames,abortEarly)=>{for(const key of fieldsNames||Object.keys(fields)){const field=get(fields,key);if(field){const{_f,...currentField}=field;if(_f){if(_f.refs&&_f.refs[0]&&action(_f.refs[0],key)&&!abortEarly)return!0;if(_f.ref&&action(_f.ref,_f.name)&&!abortEarly)return!0;if(iterateFieldsByAction(currentField,action))break}else if(isObject$1(currentField)&&iterateFieldsByAction(currentField,action))break}}};function schemaErrorLookup(errors,_fields,name){const error=get(errors,name);if(error||isKey(name))return{error,name};const names=name.split(".");for(;names.length;){const fieldName=names.join("."),field=get(_fields,fieldName),foundError=get(errors,fieldName);if(field&&!Array.isArray(field)&&name!==fieldName)return{name};if(foundError&&foundError.type)return{name:fieldName,error:foundError};if(foundError&&foundError.root&&foundError.root.type)return{name:`${fieldName}.root`,error:foundError.root};names.pop()}return{name}}var shouldRenderFormState=(formStateData,_proxyFormState,updateFormState,isRoot)=>{updateFormState(formStateData);const{name,...formState}=formStateData;return isEmptyObject(formState)||Object.keys(formState).length>=Object.keys(_proxyFormState).length||Object.keys(formState).find(key=>_proxyFormState[key]===(!isRoot||VALIDATION_MODE.all))},shouldSubscribeByName=(name,signalName,exact)=>!name||!signalName||name===signalName||convertToArrayPayload(name).some(currentName=>currentName&&(exact?currentName===signalName:currentName.startsWith(signalName)||signalName.startsWith(currentName))),skipValidation=(isBlurEvent,isTouched,isSubmitted,reValidateMode,mode)=>mode.isOnAll?!1:!isSubmitted&&mode.isOnTouch?!(isTouched||isBlurEvent):(isSubmitted?reValidateMode.isOnBlur:mode.isOnBlur)?!isBlurEvent:(isSubmitted?reValidateMode.isOnChange:mode.isOnChange)?isBlurEvent:!0,unsetEmptyArray=(ref,name)=>!compact(get(ref,name)).length&&unset(ref,name),updateFieldArrayRootError=(errors,error,name)=>{const fieldArrayErrors=convertToArrayPayload(get(errors,name));return set(fieldArrayErrors,"root",error[name]),set(errors,name,fieldArrayErrors),errors};function getValidateError(result,ref,type="validate"){if(isString(result)||Array.isArray(result)&&result.every(isString)||isBoolean(result)&&!result)return{type,message:isString(result)?result:"",ref}}var getValueAndMessage=validationData=>isObject$1(validationData)&&!isRegex(validationData)?validationData:{value:validationData,message:""},validateField=async(field,disabledFieldNames,formValues,validateAllFieldCriteria,shouldUseNativeValidation,isFieldArray)=>{const{ref,refs,required:required2,maxLength,minLength,min,max,pattern,validate,name,valueAsNumber,mount}=field._f,inputValue=get(formValues,name);if(!mount||disabledFieldNames.has(name))return{};const inputRef=refs?refs[0]:ref,setCustomValidity=message=>{shouldUseNativeValidation&&inputRef.reportValidity&&(inputRef.setCustomValidity(isBoolean(message)?"":message||""),inputRef.reportValidity())},error={},isRadio=isRadioInput(ref),isCheckBox=isCheckBoxInput(ref),isRadioOrCheckbox2=isRadio||isCheckBox,isEmpty=(valueAsNumber||isFileInput(ref))&&isUndefined(ref.value)&&isUndefined(inputValue)||isHTMLElement(ref)&&ref.value===""||inputValue===""||Array.isArray(inputValue)&&!inputValue.length,appendErrorsCurry=appendErrors.bind(null,name,validateAllFieldCriteria,error),getMinMaxMessage=(exceedMax,maxLengthMessage,minLengthMessage,maxType=INPUT_VALIDATION_RULES.maxLength,minType=INPUT_VALIDATION_RULES.minLength)=>{const message=exceedMax?maxLengthMessage:minLengthMessage;error[name]={type:exceedMax?maxType:minType,message,ref,...appendErrorsCurry(exceedMax?maxType:minType,message)}};if(isFieldArray?!Array.isArray(inputValue)||!inputValue.length:required2&&(!isRadioOrCheckbox2&&(isEmpty||isNullOrUndefined(inputValue))||isBoolean(inputValue)&&!inputValue||isCheckBox&&!getCheckboxValue(refs).isValid||isRadio&&!getRadioValue(refs).isValid)){const{value,message}=isString(required2)?{value:!!required2,message:required2}:getValueAndMessage(required2);if(value&&(error[name]={type:INPUT_VALIDATION_RULES.required,message,ref:inputRef,...appendErrorsCurry(INPUT_VALIDATION_RULES.required,message)},!validateAllFieldCriteria))return setCustomValidity(message),error}if(!isEmpty&&(!isNullOrUndefined(min)||!isNullOrUndefined(max))){let exceedMax,exceedMin;const maxOutput=getValueAndMessage(max),minOutput=getValueAndMessage(min);if(!isNullOrUndefined(inputValue)&&!isNaN(inputValue)){const valueNumber=ref.valueAsNumber||inputValue&&+inputValue;isNullOrUndefined(maxOutput.value)||(exceedMax=valueNumber>maxOutput.value),isNullOrUndefined(minOutput.value)||(exceedMin=valueNumber<minOutput.value)}else{const valueDate=ref.valueAsDate||new Date(inputValue),convertTimeToDate=time2=>new Date(new Date().toDateString()+" "+time2),isTime=ref.type=="time",isWeek=ref.type=="week";isString(maxOutput.value)&&inputValue&&(exceedMax=isTime?convertTimeToDate(inputValue)>convertTimeToDate(maxOutput.value):isWeek?inputValue>maxOutput.value:valueDate>new Date(maxOutput.value)),isString(minOutput.value)&&inputValue&&(exceedMin=isTime?convertTimeToDate(inputValue)<convertTimeToDate(minOutput.value):isWeek?inputValue<minOutput.value:valueDate<new Date(minOutput.value))}if((exceedMax||exceedMin)&&(getMinMaxMessage(!!exceedMax,maxOutput.message,minOutput.message,INPUT_VALIDATION_RULES.max,INPUT_VALIDATION_RULES.min),!validateAllFieldCriteria))return setCustomValidity(error[name].message),error}if((maxLength||minLength)&&!isEmpty&&(isString(inputValue)||isFieldArray&&Array.isArray(inputValue))){const maxLengthOutput=getValueAndMessage(maxLength),minLengthOutput=getValueAndMessage(minLength),exceedMax=!isNullOrUndefined(maxLengthOutput.value)&&inputValue.length>+maxLengthOutput.value,exceedMin=!isNullOrUndefined(minLengthOutput.value)&&inputValue.length<+minLengthOutput.value;if((exceedMax||exceedMin)&&(getMinMaxMessage(exceedMax,maxLengthOutput.message,minLengthOutput.message),!validateAllFieldCriteria))return setCustomValidity(error[name].message),error}if(pattern&&!isEmpty&&isString(inputValue)){const{value:patternValue,message}=getValueAndMessage(pattern);if(isRegex(patternValue)&&!inputValue.match(patternValue)&&(error[name]={type:INPUT_VALIDATION_RULES.pattern,message,ref,...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern,message)},!validateAllFieldCriteria))return setCustomValidity(message),error}if(validate){if(isFunction(validate)){const result=await validate(inputValue,formValues),validateError=getValidateError(result,inputRef);if(validateError&&(error[name]={...validateError,...appendErrorsCurry(INPUT_VALIDATION_RULES.validate,validateError.message)},!validateAllFieldCriteria))return setCustomValidity(validateError.message),error}else if(isObject$1(validate)){let validationResult={};for(const key in validate){if(!isEmptyObject(validationResult)&&!validateAllFieldCriteria)break;const validateError=getValidateError(await validate[key](inputValue,formValues),inputRef,key);validateError&&(validationResult={...validateError,...appendErrorsCurry(key,validateError.message)},setCustomValidity(validateError.message),validateAllFieldCriteria&&(error[name]=validationResult))}if(!isEmptyObject(validationResult)&&(error[name]={ref:inputRef,...validationResult},!validateAllFieldCriteria))return error}}return setCustomValidity(!0),error};const defaultOptions={mode:VALIDATION_MODE.onSubmit,reValidateMode:VALIDATION_MODE.onChange,shouldFocusError:!0};function createFormControl(props={}){let _options={...defaultOptions,...props},_formState={submitCount:0,isDirty:!1,isReady:!1,isLoading:isFunction(_options.defaultValues),isValidating:!1,isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,touchedFields:{},dirtyFields:{},validatingFields:{},errors:_options.errors||{},disabled:_options.disabled||!1},_fields={},_defaultValues=isObject$1(_options.defaultValues)||isObject$1(_options.values)?cloneObject(_options.defaultValues||_options.values)||{}:{},_formValues=_options.shouldUnregister?{}:cloneObject(_defaultValues),_state={action:!1,mount:!1,watch:!1},_names={mount:new Set,disabled:new Set,unMount:new Set,array:new Set,watch:new Set},delayErrorCallback,timer=0;const _proxyFormState={isDirty:!1,dirtyFields:!1,validatingFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1};let _proxySubscribeFormState={..._proxyFormState};const _subjects={array:createSubject(),state:createSubject()},shouldDisplayAllAssociatedErrors=_options.criteriaMode===VALIDATION_MODE.all,debounce=callback=>wait=>{clearTimeout(timer),timer=setTimeout(callback,wait)},_setValid=async shouldUpdateValid=>{if(!_options.disabled&&(_proxyFormState.isValid||_proxySubscribeFormState.isValid||shouldUpdateValid)){const isValid=_options.resolver?isEmptyObject((await _runSchema()).errors):await executeBuiltInValidation(_fields,!0);isValid!==_formState.isValid&&_subjects.state.next({isValid})}},_updateIsValidating=(names,isValidating)=>{!_options.disabled&&(_proxyFormState.isValidating||_proxyFormState.validatingFields||_proxySubscribeFormState.isValidating||_proxySubscribeFormState.validatingFields)&&((names||Array.from(_names.mount)).forEach(name=>{name&&(isValidating?set(_formState.validatingFields,name,isValidating):unset(_formState.validatingFields,name))}),_subjects.state.next({validatingFields:_formState.validatingFields,isValidating:!isEmptyObject(_formState.validatingFields)}))},_setFieldArray=(name,values=[],method,args,shouldSetValues=!0,shouldUpdateFieldsAndState=!0)=>{if(args&&method&&!_options.disabled){if(_state.action=!0,shouldUpdateFieldsAndState&&Array.isArray(get(_fields,name))){const fieldValues=method(get(_fields,name),args.argA,args.argB);shouldSetValues&&set(_fields,name,fieldValues)}if(shouldUpdateFieldsAndState&&Array.isArray(get(_formState.errors,name))){const errors=method(get(_formState.errors,name),args.argA,args.argB);shouldSetValues&&set(_formState.errors,name,errors),unsetEmptyArray(_formState.errors,name)}if((_proxyFormState.touchedFields||_proxySubscribeFormState.touchedFields)&&shouldUpdateFieldsAndState&&Array.isArray(get(_formState.touchedFields,name))){const touchedFields=method(get(_formState.touchedFields,name),args.argA,args.argB);shouldSetValues&&set(_formState.touchedFields,name,touchedFields)}(_proxyFormState.dirtyFields||_proxySubscribeFormState.dirtyFields)&&(_formState.dirtyFields=getDirtyFields(_defaultValues,_formValues)),_subjects.state.next({name,isDirty:_getDirty(name,values),dirtyFields:_formState.dirtyFields,errors:_formState.errors,isValid:_formState.isValid})}else set(_formValues,name,values)},updateErrors=(name,error)=>{set(_formState.errors,name,error),_subjects.state.next({errors:_formState.errors})},_setErrors=errors=>{_formState.errors=errors,_subjects.state.next({errors:_formState.errors,isValid:!1})},updateValidAndValue=(name,shouldSkipSetValueAs,value,ref)=>{const field=get(_fields,name);if(field){const defaultValue=get(_formValues,name,isUndefined(value)?get(_defaultValues,name):value);isUndefined(defaultValue)||ref&&ref.defaultChecked||shouldSkipSetValueAs?set(_formValues,name,shouldSkipSetValueAs?defaultValue:getFieldValue(field._f)):setFieldValue(name,defaultValue),_state.mount&&!_state.action&&_setValid()}},updateTouchAndDirty=(name,fieldValue,isBlurEvent,shouldDirty,shouldRender)=>{let shouldUpdateField=!1,isPreviousDirty=!1;const output={name};if(!_options.disabled){if(!isBlurEvent||shouldDirty){(_proxyFormState.isDirty||_proxySubscribeFormState.isDirty)&&(isPreviousDirty=_formState.isDirty,_formState.isDirty=output.isDirty=_getDirty(),shouldUpdateField=isPreviousDirty!==output.isDirty);const isCurrentFieldPristine=deepEqual(get(_defaultValues,name),fieldValue);isPreviousDirty=!!get(_formState.dirtyFields,name),isCurrentFieldPristine?unset(_formState.dirtyFields,name):set(_formState.dirtyFields,name,!0),output.dirtyFields=_formState.dirtyFields,shouldUpdateField=shouldUpdateField||(_proxyFormState.dirtyFields||_proxySubscribeFormState.dirtyFields)&&isPreviousDirty!==!isCurrentFieldPristine}if(isBlurEvent){const isPreviousFieldTouched=get(_formState.touchedFields,name);isPreviousFieldTouched||(set(_formState.touchedFields,name,isBlurEvent),output.touchedFields=_formState.touchedFields,shouldUpdateField=shouldUpdateField||(_proxyFormState.touchedFields||_proxySubscribeFormState.touchedFields)&&isPreviousFieldTouched!==isBlurEvent)}shouldUpdateField&&shouldRender&&_subjects.state.next(output)}return shouldUpdateField?output:{}},shouldRenderByError=(name,isValid,error,fieldState)=>{const previousFieldError=get(_formState.errors,name),shouldUpdateValid=(_proxyFormState.isValid||_proxySubscribeFormState.isValid)&&isBoolean(isValid)&&_formState.isValid!==isValid;if(_options.delayError&&error?(delayErrorCallback=debounce(()=>updateErrors(name,error)),delayErrorCallback(_options.delayError)):(clearTimeout(timer),delayErrorCallback=null,error?set(_formState.errors,name,error):unset(_formState.errors,name)),(error?!deepEqual(previousFieldError,error):previousFieldError)||!isEmptyObject(fieldState)||shouldUpdateValid){const updatedFormState={...fieldState,...shouldUpdateValid&&isBoolean(isValid)?{isValid}:{},errors:_formState.errors,name};_formState={..._formState,...updatedFormState},_subjects.state.next(updatedFormState)}},_runSchema=async name=>{_updateIsValidating(name,!0);const result=await _options.resolver(_formValues,_options.context,getResolverOptions(name||_names.mount,_fields,_options.criteriaMode,_options.shouldUseNativeValidation));return _updateIsValidating(name),result},executeSchemaAndUpdateState=async names=>{const{errors}=await _runSchema(names);if(names)for(const name of names){const error=get(errors,name);error?set(_formState.errors,name,error):unset(_formState.errors,name)}else _formState.errors=errors;return errors},executeBuiltInValidation=async(fields,shouldOnlyCheckValid,context={valid:!0})=>{for(const name in fields){const field=fields[name];if(field){const{_f,...fieldValue}=field;if(_f){const isFieldArrayRoot=_names.array.has(_f.name),isPromiseFunction=field._f&&hasPromiseValidation(field._f);isPromiseFunction&&_proxyFormState.validatingFields&&_updateIsValidating([_f.name],!0);const fieldError=await validateField(field,_names.disabled,_formValues,shouldDisplayAllAssociatedErrors,_options.shouldUseNativeValidation&&!shouldOnlyCheckValid,isFieldArrayRoot);if(isPromiseFunction&&_proxyFormState.validatingFields&&_updateIsValidating([_f.name]),fieldError[_f.name]&&(context.valid=!1,shouldOnlyCheckValid))break;!shouldOnlyCheckValid&&(get(fieldError,_f.name)?isFieldArrayRoot?updateFieldArrayRootError(_formState.errors,fieldError,_f.name):set(_formState.errors,_f.name,fieldError[_f.name]):unset(_formState.errors,_f.name))}!isEmptyObject(fieldValue)&&await executeBuiltInValidation(fieldValue,shouldOnlyCheckValid,context)}}return context.valid},_removeUnmounted=()=>{for(const name of _names.unMount){const field=get(_fields,name);field&&(field._f.refs?field._f.refs.every(ref=>!live(ref)):!live(field._f.ref))&&unregister(name)}_names.unMount=new Set},_getDirty=(name,data)=>!_options.disabled&&(name&&data&&set(_formValues,name,data),!deepEqual(getValues(),_defaultValues)),_getWatch=(names,defaultValue,isGlobal)=>generateWatchOutput(names,_names,{..._state.mount?_formValues:isUndefined(defaultValue)?_defaultValues:isString(names)?{[names]:defaultValue}:defaultValue},isGlobal,defaultValue),_getFieldArray=name=>compact(get(_state.mount?_formValues:_defaultValues,name,_options.shouldUnregister?get(_defaultValues,name,[]):[])),setFieldValue=(name,value,options={})=>{const field=get(_fields,name);let fieldValue=value;if(field){const fieldReference=field._f;fieldReference&&(!fieldReference.disabled&&set(_formValues,name,getFieldValueAs(value,fieldReference)),fieldValue=isHTMLElement(fieldReference.ref)&&isNullOrUndefined(value)?"":value,isMultipleSelect(fieldReference.ref)?[...fieldReference.ref.options].forEach(optionRef=>optionRef.selected=fieldValue.includes(optionRef.value)):fieldReference.refs?isCheckBoxInput(fieldReference.ref)?fieldReference.refs.forEach(checkboxRef=>{(!checkboxRef.defaultChecked||!checkboxRef.disabled)&&(Array.isArray(fieldValue)?checkboxRef.checked=!!fieldValue.find(data=>data===checkboxRef.value):checkboxRef.checked=fieldValue===checkboxRef.value||!!fieldValue)}):fieldReference.refs.forEach(radioRef=>radioRef.checked=radioRef.value===fieldValue):isFileInput(fieldReference.ref)?fieldReference.ref.value="":(fieldReference.ref.value=fieldValue,fieldReference.ref.type||_subjects.state.next({name,values:cloneObject(_formValues)})))}(options.shouldDirty||options.shouldTouch)&&updateTouchAndDirty(name,fieldValue,options.shouldTouch,options.shouldDirty,!0),options.shouldValidate&&trigger(name)},setValues=(name,value,options)=>{for(const fieldKey in value){if(!value.hasOwnProperty(fieldKey))return;const fieldValue=value[fieldKey],fieldName=name+"."+fieldKey,field=get(_fields,fieldName);(_names.array.has(name)||isObject$1(fieldValue)||field&&!field._f)&&!isDateObject(fieldValue)?setValues(fieldName,fieldValue,options):setFieldValue(fieldName,fieldValue,options)}},setValue=(name,value,options={})=>{const field=get(_fields,name),isFieldArray=_names.array.has(name),cloneValue=cloneObject(value);set(_formValues,name,cloneValue),isFieldArray?(_subjects.array.next({name,values:cloneObject(_formValues)}),(_proxyFormState.isDirty||_proxyFormState.dirtyFields||_proxySubscribeFormState.isDirty||_proxySubscribeFormState.dirtyFields)&&options.shouldDirty&&_subjects.state.next({name,dirtyFields:getDirtyFields(_defaultValues,_formValues),isDirty:_getDirty(name,cloneValue)})):field&&!field._f&&!isNullOrUndefined(cloneValue)?setValues(name,cloneValue,options):setFieldValue(name,cloneValue,options),isWatched(name,_names)&&_subjects.state.next({..._formState,name}),_subjects.state.next({name:_state.mount?name:void 0,values:cloneObject(_formValues)})},onChange=async event=>{_state.mount=!0;const target=event.target;let name=target.name,isFieldValueUpdated=!0;const field=get(_fields,name),_updateIsFieldValueUpdated=fieldValue=>{isFieldValueUpdated=Number.isNaN(fieldValue)||isDateObject(fieldValue)&&isNaN(fieldValue.getTime())||deepEqual(fieldValue,get(_formValues,name,fieldValue))},validationModeBeforeSubmit=getValidationModes(_options.mode),validationModeAfterSubmit=getValidationModes(_options.reValidateMode);if(field){let error,isValid;const fieldValue=target.type?getFieldValue(field._f):getEventValue(event),isBlurEvent=event.type===EVENTS.BLUR||event.type===EVENTS.FOCUS_OUT,shouldSkipValidation=!hasValidation(field._f)&&!_options.resolver&&!get(_formState.errors,name)&&!field._f.deps||skipValidation(isBlurEvent,get(_formState.touchedFields,name),_formState.isSubmitted,validationModeAfterSubmit,validationModeBeforeSubmit),watched=isWatched(name,_names,isBlurEvent);set(_formValues,name,fieldValue),isBlurEvent?(!target||!target.readOnly)&&(field._f.onBlur&&field._f.onBlur(event),delayErrorCallback&&delayErrorCallback(0)):field._f.onChange&&field._f.onChange(event);const fieldState=updateTouchAndDirty(name,fieldValue,isBlurEvent),shouldRender=!isEmptyObject(fieldState)||watched;if(!isBlurEvent&&_subjects.state.next({name,type:event.type,values:cloneObject(_formValues)}),shouldSkipValidation)return(_proxyFormState.isValid||_proxySubscribeFormState.isValid)&&(_options.mode==="onBlur"?isBlurEvent&&_setValid():isBlurEvent||_setValid()),shouldRender&&_subjects.state.next({name,...watched?{}:fieldState});if(!isBlurEvent&&watched&&_subjects.state.next({..._formState}),_options.resolver){const{errors}=await _runSchema([name]);if(_updateIsFieldValueUpdated(fieldValue),isFieldValueUpdated){const previousErrorLookupResult=schemaErrorLookup(_formState.errors,_fields,name),errorLookupResult=schemaErrorLookup(errors,_fields,previousErrorLookupResult.name||name);error=errorLookupResult.error,name=errorLookupResult.name,isValid=isEmptyObject(errors)}}else _updateIsValidating([name],!0),error=(await validateField(field,_names.disabled,_formValues,shouldDisplayAllAssociatedErrors,_options.shouldUseNativeValidation))[name],_updateIsValidating([name]),_updateIsFieldValueUpdated(fieldValue),isFieldValueUpdated&&(error?isValid=!1:(_proxyFormState.isValid||_proxySubscribeFormState.isValid)&&(isValid=await executeBuiltInValidation(_fields,!0)));isFieldValueUpdated&&(field._f.deps&&(!Array.isArray(field._f.deps)||field._f.deps.length>0)&&trigger(field._f.deps),shouldRenderByError(name,isValid,error,fieldState))}},_focusInput=(ref,key)=>{if(get(_formState.errors,key)&&ref.focus)return ref.focus(),1},trigger=async(name,options={})=>{let isValid,validationResult;const fieldNames=convertToArrayPayload(name);if(_options.resolver){const errors=await executeSchemaAndUpdateState(isUndefined(name)?name:fieldNames);isValid=isEmptyObject(errors),validationResult=name?!fieldNames.some(name2=>get(errors,name2)):isValid}else name?(validationResult=(await Promise.all(fieldNames.map(async fieldName=>{const field=get(_fields,fieldName);return await executeBuiltInValidation(field&&field._f?{[fieldName]:field}:field)}))).every(Boolean),!(!validationResult&&!_formState.isValid)&&_setValid()):validationResult=isValid=await executeBuiltInValidation(_fields);return _subjects.state.next({...!isString(name)||(_proxyFormState.isValid||_proxySubscribeFormState.isValid)&&isValid!==_formState.isValid?{}:{name},..._options.resolver||!name?{isValid}:{},errors:_formState.errors}),options.shouldFocus&&!validationResult&&iterateFieldsByAction(_fields,_focusInput,name?fieldNames:_names.mount),validationResult},getValues=(fieldNames,config2)=>{let values={..._state.mount?_formValues:_defaultValues};return config2&&(values=extractFormValues(config2.dirtyFields?_formState.dirtyFields:_formState.touchedFields,values)),isUndefined(fieldNames)?values:isString(fieldNames)?get(values,fieldNames):fieldNames.map(name=>get(values,name))},getFieldState=(name,formState)=>({invalid:!!get((formState||_formState).errors,name),isDirty:!!get((formState||_formState).dirtyFields,name),error:get((formState||_formState).errors,name),isValidating:!!get(_formState.validatingFields,name),isTouched:!!get((formState||_formState).touchedFields,name)}),clearErrors=name=>{name&&convertToArrayPayload(name).forEach(inputName=>unset(_formState.errors,inputName)),_subjects.state.next({errors:name?_formState.errors:{}})},setError=(name,error,options)=>{const ref=(get(_fields,name,{_f:{}})._f||{}).ref,currentError=get(_formState.errors,name)||{},{ref:currentRef,message,type,...restOfErrorTree}=currentError;set(_formState.errors,name,{...restOfErrorTree,...error,ref}),_subjects.state.next({name,errors:_formState.errors,isValid:!1}),options&&options.shouldFocus&&ref&&ref.focus&&ref.focus()},watch=(name,defaultValue)=>isFunction(name)?_subjects.state.subscribe({next:payload=>"values"in payload&&name(_getWatch(void 0,defaultValue),payload)}):_getWatch(name,defaultValue,!0),_subscribe=props2=>_subjects.state.subscribe({next:formState=>{shouldSubscribeByName(props2.name,formState.name,props2.exact)&&shouldRenderFormState(formState,props2.formState||_proxyFormState,_setFormState,props2.reRenderRoot)&&props2.callback({values:{..._formValues},..._formState,...formState,defaultValues:_defaultValues})}}).unsubscribe,subscribe=props2=>(_state.mount=!0,_proxySubscribeFormState={..._proxySubscribeFormState,...props2.formState},_subscribe({...props2,formState:_proxySubscribeFormState})),unregister=(name,options={})=>{for(const fieldName of name?convertToArrayPayload(name):_names.mount)_names.mount.delete(fieldName),_names.array.delete(fieldName),options.keepValue||(unset(_fields,fieldName),unset(_formValues,fieldName)),!options.keepError&&unset(_formState.errors,fieldName),!options.keepDirty&&unset(_formState.dirtyFields,fieldName),!options.keepTouched&&unset(_formState.touchedFields,fieldName),!options.keepIsValidating&&unset(_formState.validatingFields,fieldName),!_options.shouldUnregister&&!options.keepDefaultValue&&unset(_defaultValues,fieldName);_subjects.state.next({values:cloneObject(_formValues)}),_subjects.state.next({..._formState,...options.keepDirty?{isDirty:_getDirty()}:{}}),!options.keepIsValid&&_setValid()},_setDisabledField=({disabled,name})=>{(isBoolean(disabled)&&_state.mount||disabled||_names.disabled.has(name))&&(disabled?_names.disabled.add(name):_names.disabled.delete(name))},register=(name,options={})=>{let field=get(_fields,name);const disabledIsDefined=isBoolean(options.disabled)||isBoolean(_options.disabled);return set(_fields,name,{...field||{},_f:{...field&&field._f?field._f:{ref:{name}},name,mount:!0,...options}}),_names.mount.add(name),field?_setDisabledField({disabled:isBoolean(options.disabled)?options.disabled:_options.disabled,name}):updateValidAndValue(name,!0,options.value),{...disabledIsDefined?{disabled:options.disabled||_options.disabled}:{},..._options.progressive?{required:!!options.required,min:getRuleValue(options.min),max:getRuleValue(options.max),minLength:getRuleValue(options.minLength),maxLength:getRuleValue(options.maxLength),pattern:getRuleValue(options.pattern)}:{},name,onChange,onBlur:onChange,ref:ref=>{if(ref){register(name,options),field=get(_fields,name);const fieldRef=isUndefined(ref.value)&&ref.querySelectorAll&&ref.querySelectorAll("input,select,textarea")[0]||ref,radioOrCheckbox=isRadioOrCheckbox(fieldRef),refs=field._f.refs||[];if(radioOrCheckbox?refs.find(option=>option===fieldRef):fieldRef===field._f.ref)return;set(_fields,name,{_f:{...field._f,...radioOrCheckbox?{refs:[...refs.filter(live),fieldRef,...Array.isArray(get(_defaultValues,name))?[{}]:[]],ref:{type:fieldRef.type,name}}:{ref:fieldRef}}}),updateValidAndValue(name,!1,void 0,fieldRef)}else field=get(_fields,name,{}),field._f&&(field._f.mount=!1),(_options.shouldUnregister||options.shouldUnregister)&&!(isNameInFieldArray(_names.array,name)&&_state.action)&&_names.unMount.add(name)}}},_focusError=()=>_options.shouldFocusError&&iterateFieldsByAction(_fields,_focusInput,_names.mount),_disableForm=disabled=>{isBoolean(disabled)&&(_subjects.state.next({disabled}),iterateFieldsByAction(_fields,(ref,name)=>{const currentField=get(_fields,name);currentField&&(ref.disabled=currentField._f.disabled||disabled,Array.isArray(currentField._f.refs)&&currentField._f.refs.forEach(inputRef=>{inputRef.disabled=currentField._f.disabled||disabled}))},0,!1))},handleSubmit=(onValid,onInvalid)=>async e=>{let onValidError;e&&(e.preventDefault&&e.preventDefault(),e.persist&&e.persist());let fieldValues=cloneObject(_formValues);if(_subjects.state.next({isSubmitting:!0}),_options.resolver){const{errors,values}=await _runSchema();_formState.errors=errors,fieldValues=cloneObject(values)}else await executeBuiltInValidation(_fields);if(_names.disabled.size)for(const name of _names.disabled)unset(fieldValues,name);if(unset(_formState.errors,"root"),isEmptyObject(_formState.errors)){_subjects.state.next({errors:{}});try{await onValid(fieldValues,e)}catch(error){onValidError=error}}else onInvalid&&await onInvalid({..._formState.errors},e),_focusError(),setTimeout(_focusError);if(_subjects.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:isEmptyObject(_formState.errors)&&!onValidError,submitCount:_formState.submitCount+1,errors:_formState.errors}),onValidError)throw onValidError},resetField=(name,options={})=>{get(_fields,name)&&(isUndefined(options.defaultValue)?setValue(name,cloneObject(get(_defaultValues,name))):(setValue(name,options.defaultValue),set(_defaultValues,name,cloneObject(options.defaultValue))),options.keepTouched||unset(_formState.touchedFields,name),options.keepDirty||(unset(_formState.dirtyFields,name),_formState.isDirty=options.defaultValue?_getDirty(name,cloneObject(get(_defaultValues,name))):_getDirty()),options.keepError||(unset(_formState.errors,name),_proxyFormState.isValid&&_setValid()),_subjects.state.next({..._formState}))},_reset=(formValues,keepStateOptions={})=>{const updatedValues=formValues?cloneObject(formValues):_defaultValues,cloneUpdatedValues=cloneObject(updatedValues),isEmptyResetValues=isEmptyObject(formValues),values=isEmptyResetValues?_defaultValues:cloneUpdatedValues;if(keepStateOptions.keepDefaultValues||(_defaultValues=updatedValues),!keepStateOptions.keepValues){if(keepStateOptions.keepDirtyValues){const fieldsToCheck=new Set([..._names.mount,...Object.keys(getDirtyFields(_defaultValues,_formValues))]);for(const fieldName of Array.from(fieldsToCheck))get(_formState.dirtyFields,fieldName)?set(values,fieldName,get(_formValues,fieldName)):setValue(fieldName,get(values,fieldName))}else{if(isWeb&&isUndefined(formValues))for(const name of _names.mount){const field=get(_fields,name);if(field&&field._f){const fieldReference=Array.isArray(field._f.refs)?field._f.refs[0]:field._f.ref;if(isHTMLElement(fieldReference)){const form=fieldReference.closest("form");if(form){form.reset();break}}}}if(keepStateOptions.keepFieldsRef)for(const fieldName of _names.mount)setValue(fieldName,get(values,fieldName));else _fields={}}_formValues=_options.shouldUnregister?keepStateOptions.keepDefaultValues?cloneObject(_defaultValues):{}:cloneObject(values),_subjects.array.next({values:{...values}}),_subjects.state.next({values:{...values}})}_names={mount:keepStateOptions.keepDirtyValues?_names.mount:new Set,unMount:new Set,array:new Set,disabled:new Set,watch:new Set,watchAll:!1,focus:""},_state.mount=!_proxyFormState.isValid||!!keepStateOptions.keepIsValid||!!keepStateOptions.keepDirtyValues||!_options.shouldUnregister&&!isEmptyObject(values),_state.watch=!!_options.shouldUnregister,_state.action=!1,keepStateOptions.keepErrors||(_formState.errors={}),_subjects.state.next({submitCount:keepStateOptions.keepSubmitCount?_formState.submitCount:0,isDirty:isEmptyResetValues?!1:keepStateOptions.keepDirty?_formState.isDirty:!!(keepStateOptions.keepDefaultValues&&!deepEqual(formValues,_defaultValues)),isSubmitted:keepStateOptions.keepIsSubmitted?_formState.isSubmitted:!1,dirtyFields:isEmptyResetValues?{}:keepStateOptions.keepDirtyValues?keepStateOptions.keepDefaultValues&&_formValues?getDirtyFields(_defaultValues,_formValues):_formState.dirtyFields:keepStateOptions.keepDefaultValues&&formValues?getDirtyFields(_defaultValues,formValues):keepStateOptions.keepDirty?_formState.dirtyFields:{},touchedFields:keepStateOptions.keepTouched?_formState.touchedFields:{},errors:keepStateOptions.keepErrors?_formState.errors:{},isSubmitSuccessful:keepStateOptions.keepIsSubmitSuccessful?_formState.isSubmitSuccessful:!1,isSubmitting:!1,defaultValues:_defaultValues})},reset=(formValues,keepStateOptions)=>_reset(isFunction(formValues)?formValues(_formValues):formValues,keepStateOptions),setFocus=(name,options={})=>{const field=get(_fields,name),fieldReference=field&&field._f;if(fieldReference){const fieldRef=fieldReference.refs?fieldReference.refs[0]:fieldReference.ref;fieldRef.focus&&(fieldRef.focus(),options.shouldSelect&&isFunction(fieldRef.select)&&fieldRef.select())}},_setFormState=updatedFormState=>{_formState={..._formState,...updatedFormState}},methods={control:{register,unregister,getFieldState,handleSubmit,setError,_subscribe,_runSchema,_focusError,_getWatch,_getDirty,_setValid,_setFieldArray,_setDisabledField,_setErrors,_getFieldArray,_reset,_resetDefaultValues:()=>isFunction(_options.defaultValues)&&_options.defaultValues().then(values=>{reset(values,_options.resetOptions),_subjects.state.next({isLoading:!1})}),_removeUnmounted,_disableForm,_subjects,_proxyFormState,get _fields(){return _fields},get _formValues(){return _formValues},get _state(){return _state},set _state(value){_state=value},get _defaultValues(){return _defaultValues},get _names(){return _names},set _names(value){_names=value},get _formState(){return _formState},get _options(){return _options},set _options(value){_options={..._options,...value}}},subscribe,trigger,register,handleSubmit,watch,setValue,getValues,reset,resetField,clearErrors,unregister,setError,setFocus,getFieldState};return{...methods,formControl:methods}}function useForm(props={}){const _formControl=u.useRef(void 0),_values=u.useRef(void 0),[formState,updateFormState]=u.useState({isDirty:!1,isValidating:!1,isLoading:isFunction(props.defaultValues),isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,submitCount:0,dirtyFields:{},touchedFields:{},validatingFields:{},errors:props.errors||{},disabled:props.disabled||!1,isReady:!1,defaultValues:isFunction(props.defaultValues)?void 0:props.defaultValues});if(!_formControl.current)if(props.formControl)_formControl.current={...props.formControl,formState},props.defaultValues&&!isFunction(props.defaultValues)&&props.formControl.reset(props.defaultValues,props.resetOptions);else{const{formControl,...rest}=createFormControl(props);_formControl.current={...rest,formState}}const control=_formControl.current.control;return control._options=props,useIsomorphicLayoutEffect(()=>{const sub=control._subscribe({formState:control._proxyFormState,callback:()=>updateFormState({...control._formState}),reRenderRoot:!0});return updateFormState(data=>({...data,isReady:!0})),control._formState.isReady=!0,sub},[control]),u.useEffect(()=>control._disableForm(props.disabled),[control,props.disabled]),u.useEffect(()=>{props.mode&&(control._options.mode=props.mode),props.reValidateMode&&(control._options.reValidateMode=props.reValidateMode)},[control,props.mode,props.reValidateMode]),u.useEffect(()=>{props.errors&&(control._setErrors(props.errors),control._focusError())},[control,props.errors]),u.useEffect(()=>{props.shouldUnregister&&control._subjects.state.next({values:control._getWatch()})},[control,props.shouldUnregister]),u.useEffect(()=>{if(control._proxyFormState.isDirty){const isDirty=control._getDirty();isDirty!==formState.isDirty&&control._subjects.state.next({isDirty})}},[control,formState.isDirty]),u.useEffect(()=>{var _a2;props.values&&!deepEqual(props.values,_values.current)?(control._reset(props.values,{keepFieldsRef:!0,...control._options.resetOptions}),!((_a2=control._options.resetOptions)===null||_a2===void 0)&&_a2.keepIsValid||control._setValid(),_values.current=props.values,updateFormState(state=>({...state}))):control._resetDefaultValues()},[control,props.values]),u.useEffect(()=>{control._state.mount||(control._setValid(),control._state.mount=!0),control._state.watch&&(control._state.watch=!1,control._subjects.state.next({...control._formState})),control._removeUnmounted()}),_formControl.current.formState=getProxyFormState(formState,control),_formControl.current}const r=(t2,r2,o2)=>{if(t2&&"reportValidity"in t2){const s2=get(o2,r2);t2.setCustomValidity(s2&&s2.message||""),t2.reportValidity()}},o=(e,t2)=>{for(const o2 in t2.fields){const s2=t2.fields[o2];s2&&s2.ref&&"reportValidity"in s2.ref?r(s2.ref,o2,e):s2&&s2.refs&&s2.refs.forEach(t3=>r(t3,o2,e))}},s$1=(r2,s2)=>{s2.shouldUseNativeValidation&&o(r2,s2);const n2={};for(const o2 in r2){const f=get(s2.fields,o2),c=Object.assign(r2[o2]||{},{ref:f&&f.ref});if(i$1(s2.names||Object.keys(r2),o2)){const r3=Object.assign({},get(n2,o2));set(r3,"root",c),set(n2,o2,r3)}else set(n2,o2,c)}return n2},i$1=(e,t2)=>{const r2=n(t2);return e.some(e2=>n(e2).match(`^${r2}\\.\\d+`))};function n(e){return e.replace(/\]|\[/g,"")}function $constructor(name,initializer2,params){function init(inst,def){if(inst._zod||Object.defineProperty(inst,"_zod",{value:{def,constr:_,traits:new Set},enumerable:!1}),inst._zod.traits.has(name))return;inst._zod.traits.add(name),initializer2(inst,def);const proto=_.prototype,keys=Object.keys(proto);for(let i2=0;i2<keys.length;i2++){const k=keys[i2];k in inst||(inst[k]=proto[k].bind(inst))}}const Parent=params?.Parent??Object;class Definition extends Parent{}Object.defineProperty(Definition,"name",{value:name});function _(def){var _a2;const inst=params?.Parent?new Definition:this;init(inst,def),(_a2=inst._zod).deferred??(_a2.deferred=[]);for(const fn of inst._zod.deferred)fn();return inst}return Object.defineProperty(_,"init",{value:init}),Object.defineProperty(_,Symbol.hasInstance,{value:inst=>params?.Parent&&inst instanceof params.Parent?!0:inst?._zod?.traits?.has(name)}),Object.defineProperty(_,"name",{value:name}),_}class $ZodAsyncError extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class $ZodEncodeError extends Error{constructor(name){super(`Encountered unidirectional transform during encode: ${name}`),this.name="ZodEncodeError"}}const globalConfig={};function config(newConfig){return globalConfig}function getEnumValues(entries){const numericValues=Object.values(entries).filter(v=>typeof v=="number");return Object.entries(entries).filter(([k,_])=>numericValues.indexOf(+k)===-1).map(([_,v])=>v)}function jsonStringifyReplacer(_,value){return typeof value=="bigint"?value.toString():value}function cached(getter){return{get value(){{const value=getter();return Object.defineProperty(this,"value",{value}),value}}}}function nullish(input){return input==null}function cleanRegex(source){const start=source.startsWith("^")?1:0,end=source.endsWith("$")?source.length-1:source.length;return source.slice(start,end)}const EVALUATING=Symbol("evaluating");function defineLazy(object2,key,getter){let value;Object.defineProperty(object2,key,{get(){if(value!==EVALUATING)return value===void 0&&(value=EVALUATING,value=getter()),value},set(v){Object.defineProperty(object2,key,{value:v})},configurable:!0})}function assignProp(target,prop,value){Object.defineProperty(target,prop,{value,writable:!0,enumerable:!0,configurable:!0})}function mergeDefs(...defs){const mergedDescriptors={};for(const def of defs){const descriptors=Object.getOwnPropertyDescriptors(def);Object.assign(mergedDescriptors,descriptors)}return Object.defineProperties({},mergedDescriptors)}function esc(str){return JSON.stringify(str)}function slugify(input){return input.toLowerCase().trim().replace(/[^\w\s-]/g,"").replace(/[\s_-]+/g,"-").replace(/^-+|-+$/g,"")}const captureStackTrace="captureStackTrace"in Error?Error.captureStackTrace:(..._args)=>{};function isObject(data){return typeof data=="object"&&data!==null&&!Array.isArray(data)}const allowsEval=cached(()=>{if(typeof navigator<"u"&&navigator?.userAgent?.includes("Cloudflare"))return!1;try{const F=Function;return new F(""),!0}catch{return!1}});function isPlainObject(o2){if(isObject(o2)===!1)return!1;const ctor=o2.constructor;if(ctor===void 0||typeof ctor!="function")return!0;const prot=ctor.prototype;return!(isObject(prot)===!1||Object.prototype.hasOwnProperty.call(prot,"isPrototypeOf")===!1)}function shallowClone(o2){return isPlainObject(o2)?{...o2}:Array.isArray(o2)?[...o2]:o2}const propertyKeyTypes=new Set(["string","number","symbol"]);function escapeRegex(str){return str.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function clone(inst,def,params){const cl=new inst._zod.constr(def??inst._zod.def);return(!def||params?.parent)&&(cl._zod.parent=inst),cl}function normalizeParams(_params){const params=_params;if(!params)return{};if(typeof params=="string")return{error:()=>params};if(params?.message!==void 0){if(params?.error!==void 0)throw new Error("Cannot specify both `message` and `error` params");params.error=params.message}return delete params.message,typeof params.error=="string"?{...params,error:()=>params.error}:params}function optionalKeys(shape){return Object.keys(shape).filter(k=>shape[k]._zod.optin==="optional"&&shape[k]._zod.optout==="optional")}function pick(schema,mask){const currDef=schema._zod.def,def=mergeDefs(schema._zod.def,{get shape(){const newShape={};for(const key in mask){if(!(key in currDef.shape))throw new Error(`Unrecognized key: "${key}"`);mask[key]&&(newShape[key]=currDef.shape[key])}return assignProp(this,"shape",newShape),newShape},checks:[]});return clone(schema,def)}function omit(schema,mask){const currDef=schema._zod.def,def=mergeDefs(schema._zod.def,{get shape(){const newShape={...schema._zod.def.shape};for(const key in mask){if(!(key in currDef.shape))throw new Error(`Unrecognized key: "${key}"`);mask[key]&&delete newShape[key]}return assignProp(this,"shape",newShape),newShape},checks:[]});return clone(schema,def)}function extend(schema,shape){if(!isPlainObject(shape))throw new Error("Invalid input to extend: expected a plain object");const checks=schema._zod.def.checks;if(checks&&checks.length>0)throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");const def=mergeDefs(schema._zod.def,{get shape(){const _shape={...schema._zod.def.shape,...shape};return assignProp(this,"shape",_shape),_shape},checks:[]});return clone(schema,def)}function safeExtend(schema,shape){if(!isPlainObject(shape))throw new Error("Invalid input to safeExtend: expected a plain object");const def={...schema._zod.def,get shape(){const _shape={...schema._zod.def.shape,...shape};return assignProp(this,"shape",_shape),_shape},checks:schema._zod.def.checks};return clone(schema,def)}function merge(a2,b){const def=mergeDefs(a2._zod.def,{get shape(){const _shape={...a2._zod.def.shape,...b._zod.def.shape};return assignProp(this,"shape",_shape),_shape},get catchall(){return b._zod.def.catchall},checks:[]});return clone(a2,def)}function partial(Class,schema,mask){const def=mergeDefs(schema._zod.def,{get shape(){const oldShape=schema._zod.def.shape,shape={...oldShape};if(mask)for(const key in mask){if(!(key in oldShape))throw new Error(`Unrecognized key: "${key}"`);mask[key]&&(shape[key]=Class?new Class({type:"optional",innerType:oldShape[key]}):oldShape[key])}else for(const key in oldShape)shape[key]=Class?new Class({type:"optional",innerType:oldShape[key]}):oldShape[key];return assignProp(this,"shape",shape),shape},checks:[]});return clone(schema,def)}function required(Class,schema,mask){const def=mergeDefs(schema._zod.def,{get shape(){const oldShape=schema._zod.def.shape,shape={...oldShape};if(mask)for(const key in mask){if(!(key in shape))throw new Error(`Unrecognized key: "${key}"`);mask[key]&&(shape[key]=new Class({type:"nonoptional",innerType:oldShape[key]}))}else for(const key in oldShape)shape[key]=new Class({type:"nonoptional",innerType:oldShape[key]});return assignProp(this,"shape",shape),shape},checks:[]});return clone(schema,def)}function aborted(x,startIndex=0){if(x.aborted===!0)return!0;for(let i2=startIndex;i2<x.issues.length;i2++)if(x.issues[i2]?.continue!==!0)return!0;return!1}function prefixIssues(path,issues){return issues.map(iss=>{var _a2;return(_a2=iss).path??(_a2.path=[]),iss.path.unshift(path),iss})}function unwrapMessage(message){return typeof message=="string"?message:message?.message}function finalizeIssue(iss,ctx,config2){const full={...iss,path:iss.path??[]};if(!iss.message){const message=unwrapMessage(iss.inst?._zod.def?.error?.(iss))??unwrapMessage(ctx?.error?.(iss))??unwrapMessage(config2.customError?.(iss))??unwrapMessage(config2.localeError?.(iss))??"Invalid input";full.message=message}return delete full.inst,delete full.continue,ctx?.reportInput||delete full.input,full}function getLengthableOrigin(input){return Array.isArray(input)?"array":typeof input=="string"?"string":"unknown"}function issue(...args){const[iss,input,inst]=args;return typeof iss=="string"?{message:iss,code:"custom",input,inst}:{...iss}}const initializer$1=(inst,def)=>{inst.name="$ZodError",Object.defineProperty(inst,"_zod",{value:inst._zod,enumerable:!1}),Object.defineProperty(inst,"issues",{value:def,enumerable:!1}),inst.message=JSON.stringify(def,jsonStringifyReplacer,2),Object.defineProperty(inst,"toString",{value:()=>inst.message,enumerable:!1})},$ZodError=$constructor("$ZodError",initializer$1),$ZodRealError=$constructor("$ZodError",initializer$1,{Parent:Error});function flattenError(error,mapper=issue2=>issue2.message){const fieldErrors={},formErrors=[];for(const sub of error.issues)sub.path.length>0?(fieldErrors[sub.path[0]]=fieldErrors[sub.path[0]]||[],fieldErrors[sub.path[0]].push(mapper(sub))):formErrors.push(mapper(sub));return{formErrors,fieldErrors}}function formatError(error,mapper=issue2=>issue2.message){const fieldErrors={_errors:[]},processError=error2=>{for(const issue2 of error2.issues)if(issue2.code==="invalid_union"&&issue2.errors.length)issue2.errors.map(issues=>processError({issues}));else if(issue2.code==="invalid_key")processError({issues:issue2.issues});else if(issue2.code==="invalid_element")processError({issues:issue2.issues});else if(issue2.path.length===0)fieldErrors._errors.push(mapper(issue2));else{let curr=fieldErrors,i2=0;for(;i2<issue2.path.length;){const el=issue2.path[i2];i2===issue2.path.length-1?(curr[el]=curr[el]||{_errors:[]},curr[el]._errors.push(mapper(issue2))):curr[el]=curr[el]||{_errors:[]},curr=curr[el],i2++}}};return processError(error),fieldErrors}const _parse=_Err=>(schema,value,_ctx,_params)=>{const ctx=_ctx?Object.assign(_ctx,{async:!1}):{async:!1},result=schema._zod.run({value,issues:[]},ctx);if(result instanceof Promise)throw new $ZodAsyncError;if(result.issues.length){const e=new(_params?.Err??_Err)(result.issues.map(iss=>finalizeIssue(iss,ctx,config())));throw captureStackTrace(e,_params?.callee),e}return result.value},parse$1=_parse($ZodRealError),_parseAsync=_Err=>async(schema,value,_ctx,params)=>{const ctx=_ctx?Object.assign(_ctx,{async:!0}):{async:!0};let result=schema._zod.run({value,issues:[]},ctx);if(result instanceof Promise&&(result=await result),result.issues.length){const e=new(params?.Err??_Err)(result.issues.map(iss=>finalizeIssue(iss,ctx,config())));throw captureStackTrace(e,params?.callee),e}return result.value},parseAsync$1=_parseAsync($ZodRealError),_safeParse=_Err=>(schema,value,_ctx)=>{const ctx=_ctx?{..._ctx,async:!1}:{async:!1},result=schema._zod.run({value,issues:[]},ctx);if(result instanceof Promise)throw new $ZodAsyncError;return result.issues.length?{success:!1,error:new(_Err??$ZodError)(result.issues.map(iss=>finalizeIssue(iss,ctx,config())))}:{success:!0,data:result.value}},safeParse$1=_safeParse($ZodRealError),_safeParseAsync=_Err=>async(schema,value,_ctx)=>{const ctx=_ctx?Object.assign(_ctx,{async:!0}):{async:!0};let result=schema._zod.run({value,issues:[]},ctx);return result instanceof Promise&&(result=await result),result.issues.length?{success:!1,error:new _Err(result.issues.map(iss=>finalizeIssue(iss,ctx,config())))}:{success:!0,data:result.value}},safeParseAsync$1=_safeParseAsync($ZodRealError),_encode=_Err=>(schema,value,_ctx)=>{const ctx=_ctx?Object.assign(_ctx,{direction:"backward"}):{direction:"backward"};return _parse(_Err)(schema,value,ctx)},_decode=_Err=>(schema,value,_ctx)=>_parse(_Err)(schema,value,_ctx),_encodeAsync=_Err=>async(schema,value,_ctx)=>{const ctx=_ctx?Object.assign(_ctx,{direction:"backward"}):{direction:"backward"};return _parseAsync(_Err)(schema,value,ctx)},_decodeAsync=_Err=>async(schema,value,_ctx)=>_parseAsync(_Err)(schema,value,_ctx),_safeEncode=_Err=>(schema,value,_ctx)=>{const ctx=_ctx?Object.assign(_ctx,{direction:"backward"}):{direction:"backward"};return _safeParse(_Err)(schema,value,ctx)},_safeDecode=_Err=>(schema,value,_ctx)=>_safeParse(_Err)(schema,value,_ctx),_safeEncodeAsync=_Err=>async(schema,value,_ctx)=>{const ctx=_ctx?Object.assign(_ctx,{direction:"backward"}):{direction:"backward"};return _safeParseAsync(_Err)(schema,value,ctx)},_safeDecodeAsync=_Err=>async(schema,value,_ctx)=>_safeParseAsync(_Err)(schema,value,_ctx),cuid=/^[cC][^\s-]{8,}$/,cuid2=/^[0-9a-z]+$/,ulid=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,xid=/^[0-9a-vA-V]{20}$/,ksuid=/^[A-Za-z0-9]{27}$/,nanoid=/^[a-zA-Z0-9_-]{21}$/,duration$1=/^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,guid=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,uuid=version2=>version2?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,email=/^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,_emoji$1="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";function emoji(){return new RegExp(_emoji$1,"u")}const ipv4=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,ipv6=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/,cidrv4=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,cidrv6=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,base64=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,base64url=/^[A-Za-z0-9_-]*$/,e164=/^\+(?:[0-9]){6,14}[0-9]$/,dateSource="(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",date$1=new RegExp(`^${dateSource}$`);function timeSource(args){const hhmm="(?:[01]\\d|2[0-3]):[0-5]\\d";return typeof args.precision=="number"?args.precision===-1?`${hhmm}`:args.precision===0?`${hhmm}:[0-5]\\d`:`${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`:`${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`}function time$1(args){return new RegExp(`^${timeSource(args)}$`)}function datetime$1(args){const time2=timeSource({precision:args.precision}),opts=["Z"];args.local&&opts.push(""),args.offset&&opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");const timeRegex=`${time2}(?:${opts.join("|")})`;return new RegExp(`^${dateSource}T(?:${timeRegex})$`)}const string$1=params=>{const regex=params?`[\\s\\S]{${params?.minimum??0},${params?.maximum??""}}`:"[\\s\\S]*";return new RegExp(`^${regex}$`)},boolean$1=/^(?:true|false)$/i,lowercase=/^[^A-Z]*$/,uppercase=/^[^a-z]*$/,$ZodCheck=$constructor("$ZodCheck",(inst,def)=>{var _a2;inst._zod??(inst._zod={}),inst._zod.def=def,(_a2=inst._zod).onattach??(_a2.onattach=[])}),$ZodCheckMaxLength=$constructor("$ZodCheckMaxLength",(inst,def)=>{var _a2;$ZodCheck.init(inst,def),(_a2=inst._zod.def).when??(_a2.when=payload=>{const val=payload.value;return!nullish(val)&&val.length!==void 0}),inst._zod.onattach.push(inst2=>{const curr=inst2._zod.bag.maximum??Number.POSITIVE_INFINITY;def.maximum<curr&&(inst2._zod.bag.maximum=def.maximum)}),inst._zod.check=payload=>{const input=payload.value;if(input.length<=def.maximum)return;const origin=getLengthableOrigin(input);payload.issues.push({origin,code:"too_big",maximum:def.maximum,inclusive:!0,input,inst,continue:!def.abort})}}),$ZodCheckMinLength=$constructor("$ZodCheckMinLength",(inst,def)=>{var _a2;$ZodCheck.init(inst,def),(_a2=inst._zod.def).when??(_a2.when=payload=>{const val=payload.value;return!nullish(val)&&val.length!==void 0}),inst._zod.onattach.push(inst2=>{const curr=inst2._zod.bag.minimum??Number.NEGATIVE_INFINITY;def.minimum>curr&&(inst2._zod.bag.minimum=def.minimum)}),inst._zod.check=payload=>{const input=payload.value;if(input.length>=def.minimum)return;const origin=getLengthableOrigin(input);payload.issues.push({origin,code:"too_small",minimum:def.minimum,inclusive:!0,input,inst,continue:!def.abort})}}),$ZodCheckLengthEquals=$constructor("$ZodCheckLengthEquals",(inst,def)=>{var _a2;$ZodCheck.init(inst,def),(_a2=inst._zod.def).when??(_a2.when=payload=>{const val=payload.value;return!nullish(val)&&val.length!==void 0}),inst._zod.onattach.push(inst2=>{const bag=inst2._zod.bag;bag.minimum=def.length,bag.maximum=def.length,bag.length=def.length}),inst._zod.check=payload=>{const input=payload.value,length=input.length;if(length===def.length)return;const origin=getLengthableOrigin(input),tooBig=length>def.length;payload.issues.push({origin,...tooBig?{code:"too_big",maximum:def.length}:{code:"too_small",minimum:def.length},inclusive:!0,exact:!0,input:payload.value,inst,continue:!def.abort})}}),$ZodCheckStringFormat=$constructor("$ZodCheckStringFormat",(inst,def)=>{var _a2,_b;$ZodCheck.init(inst,def),inst._zod.onattach.push(inst2=>{const bag=inst2._zod.bag;bag.format=def.format,def.pattern&&(bag.patterns??(bag.patterns=new Set),bag.patterns.add(def.pattern))}),def.pattern?(_a2=inst._zod).check??(_a2.check=payload=>{def.pattern.lastIndex=0,!def.pattern.test(payload.value)&&payload.issues.push({origin:"string",code:"invalid_format",format:def.format,input:payload.value,...def.pattern?{pattern:def.pattern.toString()}:{},inst,continue:!def.abort})}):(_b=inst._zod).check??(_b.check=()=>{})}),$ZodCheckRegex=$constructor("$ZodCheckRegex",(inst,def)=>{$ZodCheckStringFormat.init(inst,def),inst._zod.check=payload=>{def.pattern.lastIndex=0,!def.pattern.test(payload.value)&&payload.issues.push({origin:"string",code:"invalid_format",format:"regex",input:payload.value,pattern:def.pattern.toString(),inst,continue:!def.abort})}}),$ZodCheckLowerCase=$constructor("$ZodCheckLowerCase",(inst,def)=>{def.pattern??(def.pattern=lowercase),$ZodCheckStringFormat.init(inst,def)}),$ZodCheckUpperCase=$constructor("$ZodCheckUpperCase",(inst,def)=>{def.pattern??(def.pattern=uppercase),$ZodCheckStringFormat.init(inst,def)}),$ZodCheckIncludes=$constructor("$ZodCheckIncludes",(inst,def)=>{$ZodCheck.init(inst,def);const escapedRegex=escapeRegex(def.includes),pattern=new RegExp(typeof def.position=="number"?`^.{${def.position}}${escapedRegex}`:escapedRegex);def.pattern=pattern,inst._zod.onattach.push(inst2=>{const bag=inst2._zod.bag;bag.patterns??(bag.patterns=new Set),bag.patterns.add(pattern)}),inst._zod.check=payload=>{payload.value.includes(def.includes,def.position)||payload.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:def.includes,input:payload.value,inst,continue:!def.abort})}}),$ZodCheckStartsWith=$constructor("$ZodCheckStartsWith",(inst,def)=>{$ZodCheck.init(inst,def);const pattern=new RegExp(`^${escapeRegex(def.prefix)}.*`);def.pattern??(def.pattern=pattern),inst._zod.onattach.push(inst2=>{const bag=inst2._zod.bag;bag.patterns??(bag.patterns=new Set),bag.patterns.add(pattern)}),inst._zod.check=payload=>{payload.value.startsWith(def.prefix)||payload.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:def.prefix,input:payload.value,inst,continue:!def.abort})}}),$ZodCheckEndsWith=$constructor("$ZodCheckEndsWith",(inst,def)=>{$ZodCheck.init(inst,def);const pattern=new RegExp(`.*${escapeRegex(def.suffix)}$`);def.pattern??(def.pattern=pattern),inst._zod.onattach.push(inst2=>{const bag=inst2._zod.bag;bag.patterns??(bag.patterns=new Set),bag.patterns.add(pattern)}),inst._zod.check=payload=>{payload.value.endsWith(def.suffix)||payload.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:def.suffix,input:payload.value,inst,continue:!def.abort})}}),$ZodCheckOverwrite=$constructor("$ZodCheckOverwrite",(inst,def)=>{$ZodCheck.init(inst,def),inst._zod.check=payload=>{payload.value=def.tx(payload.value)}});class Doc{constructor(args=[]){this.content=[],this.indent=0,this&&(this.args=args)}indented(fn){this.indent+=1,fn(this),this.indent-=1}write(arg){if(typeof arg=="function"){arg(this,{execution:"sync"}),arg(this,{execution:"async"});return}const lines=arg.split(`
`).filter(x=>x),minIndent=Math.min(...lines.map(x=>x.length-x.trimStart().length)),dedented=lines.map(x=>x.slice(minIndent)).map(x=>" ".repeat(this.indent*2)+x);for(const line of dedented)this.content.push(line)}compile(){const F=Function,args=this?.args,lines=[...(this?.content??[""]).map(x=>`  ${x}`)];return new F(...args,lines.join(`
`))}}const version={major:4,minor:1,patch:13},$ZodType=$constructor("$ZodType",(inst,def)=>{var _a2;inst??(inst={}),inst._zod.def=def,inst._zod.bag=inst._zod.bag||{},inst._zod.version=version;const checks=[...inst._zod.def.checks??[]];inst._zod.traits.has("$ZodCheck")&&checks.unshift(inst);for(const ch of checks)for(const fn of ch._zod.onattach)fn(inst);if(checks.length===0)(_a2=inst._zod).deferred??(_a2.deferred=[]),inst._zod.deferred?.push(()=>{inst._zod.run=inst._zod.parse});else{const runChecks=(payload,checks2,ctx)=>{let isAborted=aborted(payload),asyncResult;for(const ch of checks2){if(ch._zod.def.when){if(!ch._zod.def.when(payload))continue}else if(isAborted)continue;const currLen=payload.issues.length,_=ch._zod.check(payload);if(_ instanceof Promise&&ctx?.async===!1)throw new $ZodAsyncError;if(asyncResult||_ instanceof Promise)asyncResult=(asyncResult??Promise.resolve()).then(async()=>{await _,payload.issues.length!==currLen&&(isAborted||(isAborted=aborted(payload,currLen)))});else{if(payload.issues.length===currLen)continue;isAborted||(isAborted=aborted(payload,currLen))}}return asyncResult?asyncResult.then(()=>payload):payload},handleCanaryResult=(canary,payload,ctx)=>{if(aborted(canary))return canary.aborted=!0,canary;const checkResult=runChecks(payload,checks,ctx);if(checkResult instanceof Promise){if(ctx.async===!1)throw new $ZodAsyncError;return checkResult.then(checkResult2=>inst._zod.parse(checkResult2,ctx))}return inst._zod.parse(checkResult,ctx)};inst._zod.run=(payload,ctx)=>{if(ctx.skipChecks)return inst._zod.parse(payload,ctx);if(ctx.direction==="backward"){const canary=inst._zod.parse({value:payload.value,issues:[]},{...ctx,skipChecks:!0});return canary instanceof Promise?canary.then(canary2=>handleCanaryResult(canary2,payload,ctx)):handleCanaryResult(canary,payload,ctx)}const result=inst._zod.parse(payload,ctx);if(result instanceof Promise){if(ctx.async===!1)throw new $ZodAsyncError;return result.then(result2=>runChecks(result2,checks,ctx))}return runChecks(result,checks,ctx)}}inst["~standard"]={validate:value=>{try{const r2=safeParse$1(inst,value);return r2.success?{value:r2.data}:{issues:r2.error?.issues}}catch{return safeParseAsync$1(inst,value).then(r2=>r2.success?{value:r2.data}:{issues:r2.error?.issues})}},vendor:"zod",version:1}}),$ZodString=$constructor("$ZodString",(inst,def)=>{$ZodType.init(inst,def),inst._zod.pattern=[...inst?._zod.bag?.patterns??[]].pop()??string$1(inst._zod.bag),inst._zod.parse=(payload,_)=>{if(def.coerce)try{payload.value=String(payload.value)}catch{}return typeof payload.value=="string"||payload.issues.push({expected:"string",code:"invalid_type",input:payload.value,inst}),payload}}),$ZodStringFormat=$constructor("$ZodStringFormat",(inst,def)=>{$ZodCheckStringFormat.init(inst,def),$ZodString.init(inst,def)}),$ZodGUID=$constructor("$ZodGUID",(inst,def)=>{def.pattern??(def.pattern=guid),$ZodStringFormat.init(inst,def)}),$ZodUUID=$constructor("$ZodUUID",(inst,def)=>{if(def.version){const v={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[def.version];if(v===void 0)throw new Error(`Invalid UUID version: "${def.version}"`);def.pattern??(def.pattern=uuid(v))}else def.pattern??(def.pattern=uuid());$ZodStringFormat.init(inst,def)}),$ZodEmail=$constructor("$ZodEmail",(inst,def)=>{def.pattern??(def.pattern=email),$ZodStringFormat.init(inst,def)}),$ZodURL=$constructor("$ZodURL",(inst,def)=>{$ZodStringFormat.init(inst,def),inst._zod.check=payload=>{try{const trimmed=payload.value.trim(),url=new URL(trimmed);def.hostname&&(def.hostname.lastIndex=0,def.hostname.test(url.hostname)||payload.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:def.hostname.source,input:payload.value,inst,continue:!def.abort})),def.protocol&&(def.protocol.lastIndex=0,def.protocol.test(url.protocol.endsWith(":")?url.protocol.slice(0,-1):url.protocol)||payload.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:def.protocol.source,input:payload.value,inst,continue:!def.abort})),def.normalize?payload.value=url.href:payload.value=trimmed;return}catch{payload.issues.push({code:"invalid_format",format:"url",input:payload.value,inst,continue:!def.abort})}}}),$ZodEmoji=$constructor("$ZodEmoji",(inst,def)=>{def.pattern??(def.pattern=emoji()),$ZodStringFormat.init(inst,def)}),$ZodNanoID=$constructor("$ZodNanoID",(inst,def)=>{def.pattern??(def.pattern=nanoid),$ZodStringFormat.init(inst,def)}),$ZodCUID=$constructor("$ZodCUID",(inst,def)=>{def.pattern??(def.pattern=cuid),$ZodStringFormat.init(inst,def)}),$ZodCUID2=$constructor("$ZodCUID2",(inst,def)=>{def.pattern??(def.pattern=cuid2),$ZodStringFormat.init(inst,def)}),$ZodULID=$constructor("$ZodULID",(inst,def)=>{def.pattern??(def.pattern=ulid),$ZodStringFormat.init(inst,def)}),$ZodXID=$constructor("$ZodXID",(inst,def)=>{def.pattern??(def.pattern=xid),$ZodStringFormat.init(inst,def)}),$ZodKSUID=$constructor("$ZodKSUID",(inst,def)=>{def.pattern??(def.pattern=ksuid),$ZodStringFormat.init(inst,def)}),$ZodISODateTime=$constructor("$ZodISODateTime",(inst,def)=>{def.pattern??(def.pattern=datetime$1(def)),$ZodStringFormat.init(inst,def)}),$ZodISODate=$constructor("$ZodISODate",(inst,def)=>{def.pattern??(def.pattern=date$1),$ZodStringFormat.init(inst,def)}),$ZodISOTime=$constructor("$ZodISOTime",(inst,def)=>{def.pattern??(def.pattern=time$1(def)),$ZodStringFormat.init(inst,def)}),$ZodISODuration=$constructor("$ZodISODuration",(inst,def)=>{def.pattern??(def.pattern=duration$1),$ZodStringFormat.init(inst,def)}),$ZodIPv4=$constructor("$ZodIPv4",(inst,def)=>{def.pattern??(def.pattern=ipv4),$ZodStringFormat.init(inst,def),inst._zod.bag.format="ipv4"}),$ZodIPv6=$constructor("$ZodIPv6",(inst,def)=>{def.pattern??(def.pattern=ipv6),$ZodStringFormat.init(inst,def),inst._zod.bag.format="ipv6",inst._zod.check=payload=>{try{new URL(`http://[${payload.value}]`)}catch{payload.issues.push({code:"invalid_format",format:"ipv6",input:payload.value,inst,continue:!def.abort})}}}),$ZodCIDRv4=$constructor("$ZodCIDRv4",(inst,def)=>{def.pattern??(def.pattern=cidrv4),$ZodStringFormat.init(inst,def)}),$ZodCIDRv6=$constructor("$ZodCIDRv6",(inst,def)=>{def.pattern??(def.pattern=cidrv6),$ZodStringFormat.init(inst,def),inst._zod.check=payload=>{const parts=payload.value.split("/");try{if(parts.length!==2)throw new Error;const[address,prefix]=parts;if(!prefix)throw new Error;const prefixNum=Number(prefix);if(`${prefixNum}`!==prefix)throw new Error;if(prefixNum<0||prefixNum>128)throw new Error;new URL(`http://[${address}]`)}catch{payload.issues.push({code:"invalid_format",format:"cidrv6",input:payload.value,inst,continue:!def.abort})}}});function isValidBase64(data){if(data==="")return!0;if(data.length%4!==0)return!1;try{return atob(data),!0}catch{return!1}}const $ZodBase64=$constructor("$ZodBase64",(inst,def)=>{def.pattern??(def.pattern=base64),$ZodStringFormat.init(inst,def),inst._zod.bag.contentEncoding="base64",inst._zod.check=payload=>{isValidBase64(payload.value)||payload.issues.push({code:"invalid_format",format:"base64",input:payload.value,inst,continue:!def.abort})}});function isValidBase64URL(data){if(!base64url.test(data))return!1;const base642=data.replace(/[-_]/g,c=>c==="-"?"+":"/"),padded=base642.padEnd(Math.ceil(base642.length/4)*4,"=");return isValidBase64(padded)}const $ZodBase64URL=$constructor("$ZodBase64URL",(inst,def)=>{def.pattern??(def.pattern=base64url),$ZodStringFormat.init(inst,def),inst._zod.bag.contentEncoding="base64url",inst._zod.check=payload=>{isValidBase64URL(payload.value)||payload.issues.push({code:"invalid_format",format:"base64url",input:payload.value,inst,continue:!def.abort})}}),$ZodE164=$constructor("$ZodE164",(inst,def)=>{def.pattern??(def.pattern=e164),$ZodStringFormat.init(inst,def)});function isValidJWT(token,algorithm=null){try{const tokensParts=token.split(".");if(tokensParts.length!==3)return!1;const[header]=tokensParts;if(!header)return!1;const parsedHeader=JSON.parse(atob(header));return!("typ"in parsedHeader&&parsedHeader?.typ!=="JWT"||!parsedHeader.alg||algorithm&&(!("alg"in parsedHeader)||parsedHeader.alg!==algorithm))}catch{return!1}}const $ZodJWT=$constructor("$ZodJWT",(inst,def)=>{$ZodStringFormat.init(inst,def),inst._zod.check=payload=>{isValidJWT(payload.value,def.alg)||payload.issues.push({code:"invalid_format",format:"jwt",input:payload.value,inst,continue:!def.abort})}}),$ZodBoolean=$constructor("$ZodBoolean",(inst,def)=>{$ZodType.init(inst,def),inst._zod.pattern=boolean$1,inst._zod.parse=(payload,_ctx)=>{if(def.coerce)try{payload.value=!!payload.value}catch{}const input=payload.value;return typeof input=="boolean"||payload.issues.push({expected:"boolean",code:"invalid_type",input,inst}),payload}}),$ZodUnknown=$constructor("$ZodUnknown",(inst,def)=>{$ZodType.init(inst,def),inst._zod.parse=payload=>payload}),$ZodNever=$constructor("$ZodNever",(inst,def)=>{$ZodType.init(inst,def),inst._zod.parse=(payload,_ctx)=>(payload.issues.push({expected:"never",code:"invalid_type",input:payload.value,inst}),payload)});function handleArrayResult(result,final,index){result.issues.length&&final.issues.push(...prefixIssues(index,result.issues)),final.value[index]=result.value}const $ZodArray=$constructor("$ZodArray",(inst,def)=>{$ZodType.init(inst,def),inst._zod.parse=(payload,ctx)=>{const input=payload.value;if(!Array.isArray(input))return payload.issues.push({expected:"array",code:"invalid_type",input,inst}),payload;payload.value=Array(input.length);const proms=[];for(let i2=0;i2<input.length;i2++){const item=input[i2],result=def.element._zod.run({value:item,issues:[]},ctx);result instanceof Promise?proms.push(result.then(result2=>handleArrayResult(result2,payload,i2))):handleArrayResult(result,payload,i2)}return proms.length?Promise.all(proms).then(()=>payload):payload}});function handlePropertyResult(result,final,key,input){result.issues.length&&final.issues.push(...prefixIssues(key,result.issues)),result.value===void 0?key in input&&(final.value[key]=void 0):final.value[key]=result.value}function normalizeDef(def){const keys=Object.keys(def.shape);for(const k of keys)if(!def.shape?.[k]?._zod?.traits?.has("$ZodType"))throw new Error(`Invalid element at key "${k}": expected a Zod schema`);const okeys=optionalKeys(def.shape);return{...def,keys,keySet:new Set(keys),numKeys:keys.length,optionalKeys:new Set(okeys)}}function handleCatchall(proms,input,payload,ctx,def,inst){const unrecognized=[],keySet=def.keySet,_catchall=def.catchall._zod,t2=_catchall.def.type;for(const key in input){if(keySet.has(key))continue;if(t2==="never"){unrecognized.push(key);continue}const r2=_catchall.run({value:input[key],issues:[]},ctx);r2 instanceof Promise?proms.push(r2.then(r3=>handlePropertyResult(r3,payload,key,input))):handlePropertyResult(r2,payload,key,input)}return unrecognized.length&&payload.issues.push({code:"unrecognized_keys",keys:unrecognized,input,inst}),proms.length?Promise.all(proms).then(()=>payload):payload}const $ZodObject=$constructor("$ZodObject",(inst,def)=>{if($ZodType.init(inst,def),!Object.getOwnPropertyDescriptor(def,"shape")?.get){const sh=def.shape;Object.defineProperty(def,"shape",{get:()=>{const newSh={...sh};return Object.defineProperty(def,"shape",{value:newSh}),newSh}})}const _normalized=cached(()=>normalizeDef(def));defineLazy(inst._zod,"propValues",()=>{const shape=def.shape,propValues={};for(const key in shape){const field=shape[key]._zod;if(field.values){propValues[key]??(propValues[key]=new Set);for(const v of field.values)propValues[key].add(v)}}return propValues});const isObject$12=isObject,catchall=def.catchall;let value;inst._zod.parse=(payload,ctx)=>{value??(value=_normalized.value);const input=payload.value;if(!isObject$12(input))return payload.issues.push({expected:"object",code:"invalid_type",input,inst}),payload;payload.value={};const proms=[],shape=value.shape;for(const key of value.keys){const r2=shape[key]._zod.run({value:input[key],issues:[]},ctx);r2 instanceof Promise?proms.push(r2.then(r3=>handlePropertyResult(r3,payload,key,input))):handlePropertyResult(r2,payload,key,input)}return catchall?handleCatchall(proms,input,payload,ctx,_normalized.value,inst):proms.length?Promise.all(proms).then(()=>payload):payload}}),$ZodObjectJIT=$constructor("$ZodObjectJIT",(inst,def)=>{$ZodObject.init(inst,def);const superParse=inst._zod.parse,_normalized=cached(()=>normalizeDef(def)),generateFastpass=shape=>{const doc=new Doc(["shape","payload","ctx"]),normalized=_normalized.value,parseStr=key=>{const k=esc(key);return`shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`};doc.write("const input = payload.value;");const ids=Object.create(null);let counter=0;for(const key of normalized.keys)ids[key]=`key_${counter++}`;doc.write("const newResult = {};");for(const key of normalized.keys){const id=ids[key],k=esc(key);doc.write(`const ${id} = ${parseStr(key)};`),doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `)}doc.write("payload.value = newResult;"),doc.write("return payload;");const fn=doc.compile();return(payload,ctx)=>fn(shape,payload,ctx)};let fastpass;const isObject$12=isObject,jit=!globalConfig.jitless,fastEnabled=jit&&allowsEval.value,catchall=def.catchall;let value;inst._zod.parse=(payload,ctx)=>{value??(value=_normalized.value);const input=payload.value;return isObject$12(input)?jit&&fastEnabled&&ctx?.async===!1&&ctx.jitless!==!0?(fastpass||(fastpass=generateFastpass(def.shape)),payload=fastpass(payload,ctx),catchall?handleCatchall([],input,payload,ctx,value,inst):payload):superParse(payload,ctx):(payload.issues.push({expected:"object",code:"invalid_type",input,inst}),payload)}});function handleUnionResults(results,final,inst,ctx){for(const result of results)if(result.issues.length===0)return final.value=result.value,final;const nonaborted=results.filter(r2=>!aborted(r2));return nonaborted.length===1?(final.value=nonaborted[0].value,nonaborted[0]):(final.issues.push({code:"invalid_union",input:final.value,inst,errors:results.map(result=>result.issues.map(iss=>finalizeIssue(iss,ctx,config())))}),final)}const $ZodUnion=$constructor("$ZodUnion",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"optin",()=>def.options.some(o2=>o2._zod.optin==="optional")?"optional":void 0),defineLazy(inst._zod,"optout",()=>def.options.some(o2=>o2._zod.optout==="optional")?"optional":void 0),defineLazy(inst._zod,"values",()=>{if(def.options.every(o2=>o2._zod.values))return new Set(def.options.flatMap(option=>Array.from(option._zod.values)))}),defineLazy(inst._zod,"pattern",()=>{if(def.options.every(o2=>o2._zod.pattern)){const patterns=def.options.map(o2=>o2._zod.pattern);return new RegExp(`^(${patterns.map(p=>cleanRegex(p.source)).join("|")})$`)}});const single=def.options.length===1,first=def.options[0]._zod.run;inst._zod.parse=(payload,ctx)=>{if(single)return first(payload,ctx);let async=!1;const results=[];for(const option of def.options){const result=option._zod.run({value:payload.value,issues:[]},ctx);if(result instanceof Promise)results.push(result),async=!0;else{if(result.issues.length===0)return result;results.push(result)}}return async?Promise.all(results).then(results2=>handleUnionResults(results2,payload,inst,ctx)):handleUnionResults(results,payload,inst,ctx)}}),$ZodIntersection=$constructor("$ZodIntersection",(inst,def)=>{$ZodType.init(inst,def),inst._zod.parse=(payload,ctx)=>{const input=payload.value,left=def.left._zod.run({value:input,issues:[]},ctx),right=def.right._zod.run({value:input,issues:[]},ctx);return left instanceof Promise||right instanceof Promise?Promise.all([left,right]).then(([left2,right2])=>handleIntersectionResults(payload,left2,right2)):handleIntersectionResults(payload,left,right)}});function mergeValues(a2,b){if(a2===b)return{valid:!0,data:a2};if(a2 instanceof Date&&b instanceof Date&&+a2==+b)return{valid:!0,data:a2};if(isPlainObject(a2)&&isPlainObject(b)){const bKeys=Object.keys(b),sharedKeys=Object.keys(a2).filter(key=>bKeys.indexOf(key)!==-1),newObj={...a2,...b};for(const key of sharedKeys){const sharedValue=mergeValues(a2[key],b[key]);if(!sharedValue.valid)return{valid:!1,mergeErrorPath:[key,...sharedValue.mergeErrorPath]};newObj[key]=sharedValue.data}return{valid:!0,data:newObj}}if(Array.isArray(a2)&&Array.isArray(b)){if(a2.length!==b.length)return{valid:!1,mergeErrorPath:[]};const newArray=[];for(let index=0;index<a2.length;index++){const itemA=a2[index],itemB=b[index],sharedValue=mergeValues(itemA,itemB);if(!sharedValue.valid)return{valid:!1,mergeErrorPath:[index,...sharedValue.mergeErrorPath]};newArray.push(sharedValue.data)}return{valid:!0,data:newArray}}return{valid:!1,mergeErrorPath:[]}}function handleIntersectionResults(result,left,right){if(left.issues.length&&result.issues.push(...left.issues),right.issues.length&&result.issues.push(...right.issues),aborted(result))return result;const merged=mergeValues(left.value,right.value);if(!merged.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);return result.value=merged.data,result}const $ZodEnum=$constructor("$ZodEnum",(inst,def)=>{$ZodType.init(inst,def);const values=getEnumValues(def.entries),valuesSet=new Set(values);inst._zod.values=valuesSet,inst._zod.pattern=new RegExp(`^(${values.filter(k=>propertyKeyTypes.has(typeof k)).map(o2=>typeof o2=="string"?escapeRegex(o2):o2.toString()).join("|")})$`),inst._zod.parse=(payload,_ctx)=>{const input=payload.value;return valuesSet.has(input)||payload.issues.push({code:"invalid_value",values,input,inst}),payload}}),$ZodTransform=$constructor("$ZodTransform",(inst,def)=>{$ZodType.init(inst,def),inst._zod.parse=(payload,ctx)=>{if(ctx.direction==="backward")throw new $ZodEncodeError(inst.constructor.name);const _out=def.transform(payload.value,payload);if(ctx.async)return(_out instanceof Promise?_out:Promise.resolve(_out)).then(output2=>(payload.value=output2,payload));if(_out instanceof Promise)throw new $ZodAsyncError;return payload.value=_out,payload}});function handleOptionalResult(result,input){return result.issues.length&&input===void 0?{issues:[],value:void 0}:result}const $ZodOptional=$constructor("$ZodOptional",(inst,def)=>{$ZodType.init(inst,def),inst._zod.optin="optional",inst._zod.optout="optional",defineLazy(inst._zod,"values",()=>def.innerType._zod.values?new Set([...def.innerType._zod.values,void 0]):void 0),defineLazy(inst._zod,"pattern",()=>{const pattern=def.innerType._zod.pattern;return pattern?new RegExp(`^(${cleanRegex(pattern.source)})?$`):void 0}),inst._zod.parse=(payload,ctx)=>{if(def.innerType._zod.optin==="optional"){const result=def.innerType._zod.run(payload,ctx);return result instanceof Promise?result.then(r2=>handleOptionalResult(r2,payload.value)):handleOptionalResult(result,payload.value)}return payload.value===void 0?payload:def.innerType._zod.run(payload,ctx)}}),$ZodNullable=$constructor("$ZodNullable",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"optin",()=>def.innerType._zod.optin),defineLazy(inst._zod,"optout",()=>def.innerType._zod.optout),defineLazy(inst._zod,"pattern",()=>{const pattern=def.innerType._zod.pattern;return pattern?new RegExp(`^(${cleanRegex(pattern.source)}|null)$`):void 0}),defineLazy(inst._zod,"values",()=>def.innerType._zod.values?new Set([...def.innerType._zod.values,null]):void 0),inst._zod.parse=(payload,ctx)=>payload.value===null?payload:def.innerType._zod.run(payload,ctx)}),$ZodDefault=$constructor("$ZodDefault",(inst,def)=>{$ZodType.init(inst,def),inst._zod.optin="optional",defineLazy(inst._zod,"values",()=>def.innerType._zod.values),inst._zod.parse=(payload,ctx)=>{if(ctx.direction==="backward")return def.innerType._zod.run(payload,ctx);if(payload.value===void 0)return payload.value=def.defaultValue,payload;const result=def.innerType._zod.run(payload,ctx);return result instanceof Promise?result.then(result2=>handleDefaultResult(result2,def)):handleDefaultResult(result,def)}});function handleDefaultResult(payload,def){return payload.value===void 0&&(payload.value=def.defaultValue),payload}const $ZodPrefault=$constructor("$ZodPrefault",(inst,def)=>{$ZodType.init(inst,def),inst._zod.optin="optional",defineLazy(inst._zod,"values",()=>def.innerType._zod.values),inst._zod.parse=(payload,ctx)=>(ctx.direction==="backward"||payload.value===void 0&&(payload.value=def.defaultValue),def.innerType._zod.run(payload,ctx))}),$ZodNonOptional=$constructor("$ZodNonOptional",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"values",()=>{const v=def.innerType._zod.values;return v?new Set([...v].filter(x=>x!==void 0)):void 0}),inst._zod.parse=(payload,ctx)=>{const result=def.innerType._zod.run(payload,ctx);return result instanceof Promise?result.then(result2=>handleNonOptionalResult(result2,inst)):handleNonOptionalResult(result,inst)}});function handleNonOptionalResult(payload,inst){return!payload.issues.length&&payload.value===void 0&&payload.issues.push({code:"invalid_type",expected:"nonoptional",input:payload.value,inst}),payload}const $ZodCatch=$constructor("$ZodCatch",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"optin",()=>def.innerType._zod.optin),defineLazy(inst._zod,"optout",()=>def.innerType._zod.optout),defineLazy(inst._zod,"values",()=>def.innerType._zod.values),inst._zod.parse=(payload,ctx)=>{if(ctx.direction==="backward")return def.innerType._zod.run(payload,ctx);const result=def.innerType._zod.run(payload,ctx);return result instanceof Promise?result.then(result2=>(payload.value=result2.value,result2.issues.length&&(payload.value=def.catchValue({...payload,error:{issues:result2.issues.map(iss=>finalizeIssue(iss,ctx,config()))},input:payload.value}),payload.issues=[]),payload)):(payload.value=result.value,result.issues.length&&(payload.value=def.catchValue({...payload,error:{issues:result.issues.map(iss=>finalizeIssue(iss,ctx,config()))},input:payload.value}),payload.issues=[]),payload)}}),$ZodPipe=$constructor("$ZodPipe",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"values",()=>def.in._zod.values),defineLazy(inst._zod,"optin",()=>def.in._zod.optin),defineLazy(inst._zod,"optout",()=>def.out._zod.optout),defineLazy(inst._zod,"propValues",()=>def.in._zod.propValues),inst._zod.parse=(payload,ctx)=>{if(ctx.direction==="backward"){const right=def.out._zod.run(payload,ctx);return right instanceof Promise?right.then(right2=>handlePipeResult(right2,def.in,ctx)):handlePipeResult(right,def.in,ctx)}const left=def.in._zod.run(payload,ctx);return left instanceof Promise?left.then(left2=>handlePipeResult(left2,def.out,ctx)):handlePipeResult(left,def.out,ctx)}});function handlePipeResult(left,next,ctx){return left.issues.length?(left.aborted=!0,left):next._zod.run({value:left.value,issues:left.issues},ctx)}const $ZodReadonly=$constructor("$ZodReadonly",(inst,def)=>{$ZodType.init(inst,def),defineLazy(inst._zod,"propValues",()=>def.innerType._zod.propValues),defineLazy(inst._zod,"values",()=>def.innerType._zod.values),defineLazy(inst._zod,"optin",()=>def.innerType?._zod?.optin),defineLazy(inst._zod,"optout",()=>def.innerType?._zod?.optout),inst._zod.parse=(payload,ctx)=>{if(ctx.direction==="backward")return def.innerType._zod.run(payload,ctx);const result=def.innerType._zod.run(payload,ctx);return result instanceof Promise?result.then(handleReadonlyResult):handleReadonlyResult(result)}});function handleReadonlyResult(payload){return payload.value=Object.freeze(payload.value),payload}const $ZodCustom=$constructor("$ZodCustom",(inst,def)=>{$ZodCheck.init(inst,def),$ZodType.init(inst,def),inst._zod.parse=(payload,_)=>payload,inst._zod.check=payload=>{const input=payload.value,r2=def.fn(input);if(r2 instanceof Promise)return r2.then(r3=>handleRefineResult(r3,payload,input,inst));handleRefineResult(r2,payload,input,inst)}});function handleRefineResult(result,payload,input,inst){if(!result){const _iss={code:"custom",input,inst,path:[...inst._zod.def.path??[]],continue:!inst._zod.def.abort};inst._zod.def.params&&(_iss.params=inst._zod.def.params),payload.issues.push(issue(_iss))}}var _a;class $ZodRegistry{constructor(){this._map=new WeakMap,this._idmap=new Map}add(schema,..._meta){const meta=_meta[0];if(this._map.set(schema,meta),meta&&typeof meta=="object"&&"id"in meta){if(this._idmap.has(meta.id))throw new Error(`ID ${meta.id} already exists in the registry`);this._idmap.set(meta.id,schema)}return this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(schema){const meta=this._map.get(schema);return meta&&typeof meta=="object"&&"id"in meta&&this._idmap.delete(meta.id),this._map.delete(schema),this}get(schema){const p=schema._zod.parent;if(p){const pm={...this.get(p)??{}};delete pm.id;const f={...pm,...this._map.get(schema)};return Object.keys(f).length?f:void 0}return this._map.get(schema)}has(schema){return this._map.has(schema)}}function registry(){return new $ZodRegistry}(_a=globalThis).__zod_globalRegistry??(_a.__zod_globalRegistry=registry());const globalRegistry=globalThis.__zod_globalRegistry;function _string(Class,params){return new Class({type:"string",...normalizeParams(params)})}function _email(Class,params){return new Class({type:"string",format:"email",check:"string_format",abort:!1,...normalizeParams(params)})}function _guid(Class,params){return new Class({type:"string",format:"guid",check:"string_format",abort:!1,...normalizeParams(params)})}function _uuid(Class,params){return new Class({type:"string",format:"uuid",check:"string_format",abort:!1,...normalizeParams(params)})}function _uuidv4(Class,params){return new Class({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v4",...normalizeParams(params)})}function _uuidv6(Class,params){return new Class({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v6",...normalizeParams(params)})}function _uuidv7(Class,params){return new Class({type:"string",format:"uuid",check:"string_format",abort:!1,version:"v7",...normalizeParams(params)})}function _url(Class,params){return new Class({type:"string",format:"url",check:"string_format",abort:!1,...normalizeParams(params)})}function _emoji(Class,params){return new Class({type:"string",format:"emoji",check:"string_format",abort:!1,...normalizeParams(params)})}function _nanoid(Class,params){return new Class({type:"string",format:"nanoid",check:"string_format",abort:!1,...normalizeParams(params)})}function _cuid(Class,params){return new Class({type:"string",format:"cuid",check:"string_format",abort:!1,...normalizeParams(params)})}function _cuid2(Class,params){return new Class({type:"string",format:"cuid2",check:"string_format",abort:!1,...normalizeParams(params)})}function _ulid(Class,params){return new Class({type:"string",format:"ulid",check:"string_format",abort:!1,...normalizeParams(params)})}function _xid(Class,params){return new Class({type:"string",format:"xid",check:"string_format",abort:!1,...normalizeParams(params)})}function _ksuid(Class,params){return new Class({type:"string",format:"ksuid",check:"string_format",abort:!1,...normalizeParams(params)})}function _ipv4(Class,params){return new Class({type:"string",format:"ipv4",check:"string_format",abort:!1,...normalizeParams(params)})}function _ipv6(Class,params){return new Class({type:"string",format:"ipv6",check:"string_format",abort:!1,...normalizeParams(params)})}function _cidrv4(Class,params){return new Class({type:"string",format:"cidrv4",check:"string_format",abort:!1,...normalizeParams(params)})}function _cidrv6(Class,params){return new Class({type:"string",format:"cidrv6",check:"string_format",abort:!1,...normalizeParams(params)})}function _base64(Class,params){return new Class({type:"string",format:"base64",check:"string_format",abort:!1,...normalizeParams(params)})}function _base64url(Class,params){return new Class({type:"string",format:"base64url",check:"string_format",abort:!1,...normalizeParams(params)})}function _e164(Class,params){return new Class({type:"string",format:"e164",check:"string_format",abort:!1,...normalizeParams(params)})}function _jwt(Class,params){return new Class({type:"string",format:"jwt",check:"string_format",abort:!1,...normalizeParams(params)})}function _isoDateTime(Class,params){return new Class({type:"string",format:"datetime",check:"string_format",offset:!1,local:!1,precision:null,...normalizeParams(params)})}function _isoDate(Class,params){return new Class({type:"string",format:"date",check:"string_format",...normalizeParams(params)})}function _isoTime(Class,params){return new Class({type:"string",format:"time",check:"string_format",precision:null,...normalizeParams(params)})}function _isoDuration(Class,params){return new Class({type:"string",format:"duration",check:"string_format",...normalizeParams(params)})}function _boolean(Class,params){return new Class({type:"boolean",...normalizeParams(params)})}function _unknown(Class){return new Class({type:"unknown"})}function _never(Class,params){return new Class({type:"never",...normalizeParams(params)})}function _maxLength(maximum,params){return new $ZodCheckMaxLength({check:"max_length",...normalizeParams(params),maximum})}function _minLength(minimum,params){return new $ZodCheckMinLength({check:"min_length",...normalizeParams(params),minimum})}function _length(length,params){return new $ZodCheckLengthEquals({check:"length_equals",...normalizeParams(params),length})}function _regex(pattern,params){return new $ZodCheckRegex({check:"string_format",format:"regex",...normalizeParams(params),pattern})}function _lowercase(params){return new $ZodCheckLowerCase({check:"string_format",format:"lowercase",...normalizeParams(params)})}function _uppercase(params){return new $ZodCheckUpperCase({check:"string_format",format:"uppercase",...normalizeParams(params)})}function _includes(includes,params){return new $ZodCheckIncludes({check:"string_format",format:"includes",...normalizeParams(params),includes})}function _startsWith(prefix,params){return new $ZodCheckStartsWith({check:"string_format",format:"starts_with",...normalizeParams(params),prefix})}function _endsWith(suffix,params){return new $ZodCheckEndsWith({check:"string_format",format:"ends_with",...normalizeParams(params),suffix})}function _overwrite(tx){return new $ZodCheckOverwrite({check:"overwrite",tx})}function _normalize(form){return _overwrite(input=>input.normalize(form))}function _trim(){return _overwrite(input=>input.trim())}function _toLowerCase(){return _overwrite(input=>input.toLowerCase())}function _toUpperCase(){return _overwrite(input=>input.toUpperCase())}function _slugify(){return _overwrite(input=>slugify(input))}function _array(Class,element,params){return new Class({type:"array",element,...normalizeParams(params)})}function _refine(Class,fn,_params){return new Class({type:"custom",check:"custom",fn,...normalizeParams(_params)})}function _superRefine(fn){const ch=_check(payload=>(payload.addIssue=issue$1=>{if(typeof issue$1=="string")payload.issues.push(issue(issue$1,payload.value,ch._zod.def));else{const _issue=issue$1;_issue.fatal&&(_issue.continue=!1),_issue.code??(_issue.code="custom"),_issue.input??(_issue.input=payload.value),_issue.inst??(_issue.inst=ch),_issue.continue??(_issue.continue=!ch._zod.def.abort),payload.issues.push(issue(_issue))}},fn(payload.value,payload)));return ch}function _check(fn,params){const ch=new $ZodCheck({check:"custom",...normalizeParams(params)});return ch._zod.check=fn,ch}function t(r2,e){try{var o2=r2()}catch(r3){return e(r3)}return o2&&o2.then?o2.then(void 0,e):o2}function s(r2,e){for(var n2={};r2.length;){var t2=r2[0],s2=t2.code,i2=t2.message,a2=t2.path.join(".");if(!n2[a2])if("unionErrors"in t2){var u2=t2.unionErrors[0].errors[0];n2[a2]={message:u2.message,type:u2.code}}else n2[a2]={message:i2,type:s2};if("unionErrors"in t2&&t2.unionErrors.forEach(function(e2){return e2.errors.forEach(function(e3){return r2.push(e3)})}),e){var c=n2[a2].types,f=c&&c[t2.code];n2[a2]=appendErrors(a2,e,n2,s2,f?[].concat(f,t2.message):t2.message)}r2.shift()}return n2}function i(r2,e){for(var n2={};r2.length;){var t2=r2[0],s2=t2.code,i2=t2.message,a2=t2.path.join(".");if(!n2[a2])if(t2.code==="invalid_union"&&t2.errors.length>0){var u2=t2.errors[0][0];n2[a2]={message:u2.message,type:u2.code}}else n2[a2]={message:i2,type:s2};if(t2.code==="invalid_union"&&t2.errors.forEach(function(e2){return e2.forEach(function(e3){return r2.push(e3)})}),e){var c=n2[a2].types,f=c&&c[t2.code];n2[a2]=appendErrors(a2,e,n2,s2,f?[].concat(f,t2.message):t2.message)}r2.shift()}return n2}function a(o$1,a2,u2){if(u2===void 0&&(u2={}),(function(r2){return"_def"in r2&&typeof r2._def=="object"&&"typeName"in r2._def})(o$1))return function(n2,i2,c){try{return Promise.resolve(t(function(){return Promise.resolve(o$1[u2.mode==="sync"?"parse":"parseAsync"](n2,a2)).then(function(e){return c.shouldUseNativeValidation&&o({},c),{errors:{},values:u2.raw?Object.assign({},n2):e}})},function(r2){if((function(r3){return Array.isArray(r3?.issues)})(r2))return{values:{},errors:s$1(s(r2.errors,!c.shouldUseNativeValidation&&c.criteriaMode==="all"),c)};throw r2}))}catch(r2){return Promise.reject(r2)}};if((function(r2){return"_zod"in r2&&typeof r2._zod=="object"})(o$1))return function(s2,c,f){try{return Promise.resolve(t(function(){return Promise.resolve((u2.mode==="sync"?parse$1:parseAsync$1)(o$1,s2,a2)).then(function(e){return f.shouldUseNativeValidation&&o({},f),{errors:{},values:u2.raw?Object.assign({},s2):e}})},function(r2){if((function(r3){return r3 instanceof $ZodError})(r2))return{values:{},errors:s$1(i(r2.issues,!f.shouldUseNativeValidation&&f.criteriaMode==="all"),f)};throw r2}))}catch(r2){return Promise.reject(r2)}};throw new Error("Invalid input: not a Zod schema")}const ZodISODateTime=$constructor("ZodISODateTime",(inst,def)=>{$ZodISODateTime.init(inst,def),ZodStringFormat.init(inst,def)});function datetime(params){return _isoDateTime(ZodISODateTime,params)}const ZodISODate=$constructor("ZodISODate",(inst,def)=>{$ZodISODate.init(inst,def),ZodStringFormat.init(inst,def)});function date(params){return _isoDate(ZodISODate,params)}const ZodISOTime=$constructor("ZodISOTime",(inst,def)=>{$ZodISOTime.init(inst,def),ZodStringFormat.init(inst,def)});function time(params){return _isoTime(ZodISOTime,params)}const ZodISODuration=$constructor("ZodISODuration",(inst,def)=>{$ZodISODuration.init(inst,def),ZodStringFormat.init(inst,def)});function duration(params){return _isoDuration(ZodISODuration,params)}const initializer=(inst,issues)=>{$ZodError.init(inst,issues),inst.name="ZodError",Object.defineProperties(inst,{format:{value:mapper=>formatError(inst,mapper)},flatten:{value:mapper=>flattenError(inst,mapper)},addIssue:{value:issue2=>{inst.issues.push(issue2),inst.message=JSON.stringify(inst.issues,jsonStringifyReplacer,2)}},addIssues:{value:issues2=>{inst.issues.push(...issues2),inst.message=JSON.stringify(inst.issues,jsonStringifyReplacer,2)}},isEmpty:{get(){return inst.issues.length===0}}})},ZodRealError=$constructor("ZodError",initializer,{Parent:Error}),parse=_parse(ZodRealError),parseAsync=_parseAsync(ZodRealError),safeParse=_safeParse(ZodRealError),safeParseAsync=_safeParseAsync(ZodRealError),encode=_encode(ZodRealError),decode=_decode(ZodRealError),encodeAsync=_encodeAsync(ZodRealError),decodeAsync=_decodeAsync(ZodRealError),safeEncode=_safeEncode(ZodRealError),safeDecode=_safeDecode(ZodRealError),safeEncodeAsync=_safeEncodeAsync(ZodRealError),safeDecodeAsync=_safeDecodeAsync(ZodRealError),ZodType=$constructor("ZodType",(inst,def)=>($ZodType.init(inst,def),inst.def=def,inst.type=def.type,Object.defineProperty(inst,"_def",{value:def}),inst.check=(...checks)=>inst.clone(mergeDefs(def,{checks:[...def.checks??[],...checks.map(ch=>typeof ch=="function"?{_zod:{check:ch,def:{check:"custom"},onattach:[]}}:ch)]})),inst.clone=(def2,params)=>clone(inst,def2,params),inst.brand=()=>inst,inst.register=((reg,meta)=>(reg.add(inst,meta),inst)),inst.parse=(data,params)=>parse(inst,data,params,{callee:inst.parse}),inst.safeParse=(data,params)=>safeParse(inst,data,params),inst.parseAsync=async(data,params)=>parseAsync(inst,data,params,{callee:inst.parseAsync}),inst.safeParseAsync=async(data,params)=>safeParseAsync(inst,data,params),inst.spa=inst.safeParseAsync,inst.encode=(data,params)=>encode(inst,data,params),inst.decode=(data,params)=>decode(inst,data,params),inst.encodeAsync=async(data,params)=>encodeAsync(inst,data,params),inst.decodeAsync=async(data,params)=>decodeAsync(inst,data,params),inst.safeEncode=(data,params)=>safeEncode(inst,data,params),inst.safeDecode=(data,params)=>safeDecode(inst,data,params),inst.safeEncodeAsync=async(data,params)=>safeEncodeAsync(inst,data,params),inst.safeDecodeAsync=async(data,params)=>safeDecodeAsync(inst,data,params),inst.refine=(check,params)=>inst.check(refine(check,params)),inst.superRefine=refinement=>inst.check(superRefine(refinement)),inst.overwrite=fn=>inst.check(_overwrite(fn)),inst.optional=()=>optional(inst),inst.nullable=()=>nullable(inst),inst.nullish=()=>optional(nullable(inst)),inst.nonoptional=params=>nonoptional(inst,params),inst.array=()=>array(inst),inst.or=arg=>union([inst,arg]),inst.and=arg=>intersection(inst,arg),inst.transform=tx=>pipe(inst,transform(tx)),inst.default=def2=>_default(inst,def2),inst.prefault=def2=>prefault(inst,def2),inst.catch=params=>_catch(inst,params),inst.pipe=target=>pipe(inst,target),inst.readonly=()=>readonly(inst),inst.describe=description=>{const cl=inst.clone();return globalRegistry.add(cl,{description}),cl},Object.defineProperty(inst,"description",{get(){return globalRegistry.get(inst)?.description},configurable:!0}),inst.meta=(...args)=>{if(args.length===0)return globalRegistry.get(inst);const cl=inst.clone();return globalRegistry.add(cl,args[0]),cl},inst.isOptional=()=>inst.safeParse(void 0).success,inst.isNullable=()=>inst.safeParse(null).success,inst)),_ZodString=$constructor("_ZodString",(inst,def)=>{$ZodString.init(inst,def),ZodType.init(inst,def);const bag=inst._zod.bag;inst.format=bag.format??null,inst.minLength=bag.minimum??null,inst.maxLength=bag.maximum??null,inst.regex=(...args)=>inst.check(_regex(...args)),inst.includes=(...args)=>inst.check(_includes(...args)),inst.startsWith=(...args)=>inst.check(_startsWith(...args)),inst.endsWith=(...args)=>inst.check(_endsWith(...args)),inst.min=(...args)=>inst.check(_minLength(...args)),inst.max=(...args)=>inst.check(_maxLength(...args)),inst.length=(...args)=>inst.check(_length(...args)),inst.nonempty=(...args)=>inst.check(_minLength(1,...args)),inst.lowercase=params=>inst.check(_lowercase(params)),inst.uppercase=params=>inst.check(_uppercase(params)),inst.trim=()=>inst.check(_trim()),inst.normalize=(...args)=>inst.check(_normalize(...args)),inst.toLowerCase=()=>inst.check(_toLowerCase()),inst.toUpperCase=()=>inst.check(_toUpperCase()),inst.slugify=()=>inst.check(_slugify())}),ZodString=$constructor("ZodString",(inst,def)=>{$ZodString.init(inst,def),_ZodString.init(inst,def),inst.email=params=>inst.check(_email(ZodEmail,params)),inst.url=params=>inst.check(_url(ZodURL,params)),inst.jwt=params=>inst.check(_jwt(ZodJWT,params)),inst.emoji=params=>inst.check(_emoji(ZodEmoji,params)),inst.guid=params=>inst.check(_guid(ZodGUID,params)),inst.uuid=params=>inst.check(_uuid(ZodUUID,params)),inst.uuidv4=params=>inst.check(_uuidv4(ZodUUID,params)),inst.uuidv6=params=>inst.check(_uuidv6(ZodUUID,params)),inst.uuidv7=params=>inst.check(_uuidv7(ZodUUID,params)),inst.nanoid=params=>inst.check(_nanoid(ZodNanoID,params)),inst.guid=params=>inst.check(_guid(ZodGUID,params)),inst.cuid=params=>inst.check(_cuid(ZodCUID,params)),inst.cuid2=params=>inst.check(_cuid2(ZodCUID2,params)),inst.ulid=params=>inst.check(_ulid(ZodULID,params)),inst.base64=params=>inst.check(_base64(ZodBase64,params)),inst.base64url=params=>inst.check(_base64url(ZodBase64URL,params)),inst.xid=params=>inst.check(_xid(ZodXID,params)),inst.ksuid=params=>inst.check(_ksuid(ZodKSUID,params)),inst.ipv4=params=>inst.check(_ipv4(ZodIPv4,params)),inst.ipv6=params=>inst.check(_ipv6(ZodIPv6,params)),inst.cidrv4=params=>inst.check(_cidrv4(ZodCIDRv4,params)),inst.cidrv6=params=>inst.check(_cidrv6(ZodCIDRv6,params)),inst.e164=params=>inst.check(_e164(ZodE164,params)),inst.datetime=params=>inst.check(datetime(params)),inst.date=params=>inst.check(date(params)),inst.time=params=>inst.check(time(params)),inst.duration=params=>inst.check(duration(params))});function string(params){return _string(ZodString,params)}const ZodStringFormat=$constructor("ZodStringFormat",(inst,def)=>{$ZodStringFormat.init(inst,def),_ZodString.init(inst,def)}),ZodEmail=$constructor("ZodEmail",(inst,def)=>{$ZodEmail.init(inst,def),ZodStringFormat.init(inst,def)}),ZodGUID=$constructor("ZodGUID",(inst,def)=>{$ZodGUID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodUUID=$constructor("ZodUUID",(inst,def)=>{$ZodUUID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodURL=$constructor("ZodURL",(inst,def)=>{$ZodURL.init(inst,def),ZodStringFormat.init(inst,def)}),ZodEmoji=$constructor("ZodEmoji",(inst,def)=>{$ZodEmoji.init(inst,def),ZodStringFormat.init(inst,def)}),ZodNanoID=$constructor("ZodNanoID",(inst,def)=>{$ZodNanoID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodCUID=$constructor("ZodCUID",(inst,def)=>{$ZodCUID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodCUID2=$constructor("ZodCUID2",(inst,def)=>{$ZodCUID2.init(inst,def),ZodStringFormat.init(inst,def)}),ZodULID=$constructor("ZodULID",(inst,def)=>{$ZodULID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodXID=$constructor("ZodXID",(inst,def)=>{$ZodXID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodKSUID=$constructor("ZodKSUID",(inst,def)=>{$ZodKSUID.init(inst,def),ZodStringFormat.init(inst,def)}),ZodIPv4=$constructor("ZodIPv4",(inst,def)=>{$ZodIPv4.init(inst,def),ZodStringFormat.init(inst,def)}),ZodIPv6=$constructor("ZodIPv6",(inst,def)=>{$ZodIPv6.init(inst,def),ZodStringFormat.init(inst,def)}),ZodCIDRv4=$constructor("ZodCIDRv4",(inst,def)=>{$ZodCIDRv4.init(inst,def),ZodStringFormat.init(inst,def)}),ZodCIDRv6=$constructor("ZodCIDRv6",(inst,def)=>{$ZodCIDRv6.init(inst,def),ZodStringFormat.init(inst,def)}),ZodBase64=$constructor("ZodBase64",(inst,def)=>{$ZodBase64.init(inst,def),ZodStringFormat.init(inst,def)}),ZodBase64URL=$constructor("ZodBase64URL",(inst,def)=>{$ZodBase64URL.init(inst,def),ZodStringFormat.init(inst,def)}),ZodE164=$constructor("ZodE164",(inst,def)=>{$ZodE164.init(inst,def),ZodStringFormat.init(inst,def)}),ZodJWT=$constructor("ZodJWT",(inst,def)=>{$ZodJWT.init(inst,def),ZodStringFormat.init(inst,def)}),ZodBoolean=$constructor("ZodBoolean",(inst,def)=>{$ZodBoolean.init(inst,def),ZodType.init(inst,def)});function boolean(params){return _boolean(ZodBoolean,params)}const ZodUnknown=$constructor("ZodUnknown",(inst,def)=>{$ZodUnknown.init(inst,def),ZodType.init(inst,def)});function unknown(){return _unknown(ZodUnknown)}const ZodNever=$constructor("ZodNever",(inst,def)=>{$ZodNever.init(inst,def),ZodType.init(inst,def)});function never(params){return _never(ZodNever,params)}const ZodArray=$constructor("ZodArray",(inst,def)=>{$ZodArray.init(inst,def),ZodType.init(inst,def),inst.element=def.element,inst.min=(minLength,params)=>inst.check(_minLength(minLength,params)),inst.nonempty=params=>inst.check(_minLength(1,params)),inst.max=(maxLength,params)=>inst.check(_maxLength(maxLength,params)),inst.length=(len,params)=>inst.check(_length(len,params)),inst.unwrap=()=>inst.element});function array(element,params){return _array(ZodArray,element,params)}const ZodObject=$constructor("ZodObject",(inst,def)=>{$ZodObjectJIT.init(inst,def),ZodType.init(inst,def),defineLazy(inst,"shape",()=>def.shape),inst.keyof=()=>_enum(Object.keys(inst._zod.def.shape)),inst.catchall=catchall=>inst.clone({...inst._zod.def,catchall}),inst.passthrough=()=>inst.clone({...inst._zod.def,catchall:unknown()}),inst.loose=()=>inst.clone({...inst._zod.def,catchall:unknown()}),inst.strict=()=>inst.clone({...inst._zod.def,catchall:never()}),inst.strip=()=>inst.clone({...inst._zod.def,catchall:void 0}),inst.extend=incoming=>extend(inst,incoming),inst.safeExtend=incoming=>safeExtend(inst,incoming),inst.merge=other=>merge(inst,other),inst.pick=mask=>pick(inst,mask),inst.omit=mask=>omit(inst,mask),inst.partial=(...args)=>partial(ZodOptional,inst,args[0]),inst.required=(...args)=>required(ZodNonOptional,inst,args[0])});function object(shape,params){const def={type:"object",shape:shape??{},...normalizeParams(params)};return new ZodObject(def)}const ZodUnion=$constructor("ZodUnion",(inst,def)=>{$ZodUnion.init(inst,def),ZodType.init(inst,def),inst.options=def.options});function union(options,params){return new ZodUnion({type:"union",options,...normalizeParams(params)})}const ZodIntersection=$constructor("ZodIntersection",(inst,def)=>{$ZodIntersection.init(inst,def),ZodType.init(inst,def)});function intersection(left,right){return new ZodIntersection({type:"intersection",left,right})}const ZodEnum=$constructor("ZodEnum",(inst,def)=>{$ZodEnum.init(inst,def),ZodType.init(inst,def),inst.enum=def.entries,inst.options=Object.values(def.entries);const keys=new Set(Object.keys(def.entries));inst.extract=(values,params)=>{const newEntries={};for(const value of values)if(keys.has(value))newEntries[value]=def.entries[value];else throw new Error(`Key ${value} not found in enum`);return new ZodEnum({...def,checks:[],...normalizeParams(params),entries:newEntries})},inst.exclude=(values,params)=>{const newEntries={...def.entries};for(const value of values)if(keys.has(value))delete newEntries[value];else throw new Error(`Key ${value} not found in enum`);return new ZodEnum({...def,checks:[],...normalizeParams(params),entries:newEntries})}});function _enum(values,params){const entries=Array.isArray(values)?Object.fromEntries(values.map(v=>[v,v])):values;return new ZodEnum({type:"enum",entries,...normalizeParams(params)})}const ZodTransform=$constructor("ZodTransform",(inst,def)=>{$ZodTransform.init(inst,def),ZodType.init(inst,def),inst._zod.parse=(payload,_ctx)=>{if(_ctx.direction==="backward")throw new $ZodEncodeError(inst.constructor.name);payload.addIssue=issue$1=>{if(typeof issue$1=="string")payload.issues.push(issue(issue$1,payload.value,def));else{const _issue=issue$1;_issue.fatal&&(_issue.continue=!1),_issue.code??(_issue.code="custom"),_issue.input??(_issue.input=payload.value),_issue.inst??(_issue.inst=inst),payload.issues.push(issue(_issue))}};const output=def.transform(payload.value,payload);return output instanceof Promise?output.then(output2=>(payload.value=output2,payload)):(payload.value=output,payload)}});function transform(fn){return new ZodTransform({type:"transform",transform:fn})}const ZodOptional=$constructor("ZodOptional",(inst,def)=>{$ZodOptional.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType});function optional(innerType){return new ZodOptional({type:"optional",innerType})}const ZodNullable=$constructor("ZodNullable",(inst,def)=>{$ZodNullable.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType});function nullable(innerType){return new ZodNullable({type:"nullable",innerType})}const ZodDefault=$constructor("ZodDefault",(inst,def)=>{$ZodDefault.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType,inst.removeDefault=inst.unwrap});function _default(innerType,defaultValue){return new ZodDefault({type:"default",innerType,get defaultValue(){return typeof defaultValue=="function"?defaultValue():shallowClone(defaultValue)}})}const ZodPrefault=$constructor("ZodPrefault",(inst,def)=>{$ZodPrefault.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType});function prefault(innerType,defaultValue){return new ZodPrefault({type:"prefault",innerType,get defaultValue(){return typeof defaultValue=="function"?defaultValue():shallowClone(defaultValue)}})}const ZodNonOptional=$constructor("ZodNonOptional",(inst,def)=>{$ZodNonOptional.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType});function nonoptional(innerType,params){return new ZodNonOptional({type:"nonoptional",innerType,...normalizeParams(params)})}const ZodCatch=$constructor("ZodCatch",(inst,def)=>{$ZodCatch.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType,inst.removeCatch=inst.unwrap});function _catch(innerType,catchValue){return new ZodCatch({type:"catch",innerType,catchValue:typeof catchValue=="function"?catchValue:()=>catchValue})}const ZodPipe=$constructor("ZodPipe",(inst,def)=>{$ZodPipe.init(inst,def),ZodType.init(inst,def),inst.in=def.in,inst.out=def.out});function pipe(in_,out){return new ZodPipe({type:"pipe",in:in_,out})}const ZodReadonly=$constructor("ZodReadonly",(inst,def)=>{$ZodReadonly.init(inst,def),ZodType.init(inst,def),inst.unwrap=()=>inst._zod.def.innerType});function readonly(innerType){return new ZodReadonly({type:"readonly",innerType})}const ZodCustom=$constructor("ZodCustom",(inst,def)=>{$ZodCustom.init(inst,def),ZodType.init(inst,def)});function refine(fn,_params={}){return _refine(ZodCustom,fn,_params)}function superRefine(fn){return _superRefine(fn)}const Form=FormProvider,FormFieldContext=reactExports.createContext(null),FormField=({...props})=>jsxRuntimeExports.jsx(FormFieldContext.Provider,{value:{name:props.name},children:jsxRuntimeExports.jsx(Controller,{...props})}),useFormField=()=>{const fieldContext=reactExports.useContext(FormFieldContext),itemContext=reactExports.useContext(FormItemContext),{getFieldState,formState}=useFormContext();if(!fieldContext)throw new Error("useFormField should be used within <FormField>");if(!itemContext)throw new Error("useFormField should be used within <FormItem>");const fieldState=getFieldState(fieldContext.name,formState),{id}=itemContext;return{id,name:fieldContext.name,formItemId:`${id}-form-item`,formDescriptionId:`${id}-form-item-description`,formMessageId:`${id}-form-item-message`,...fieldState}},FormItemContext=reactExports.createContext(null),FormItem=reactExports.forwardRef(({className,...props},ref)=>{const id=reactExports.useId();return jsxRuntimeExports.jsx(FormItemContext.Provider,{value:{id},children:jsxRuntimeExports.jsx("div",{ref,className:cn("space-y-2",className),...props})})});FormItem.displayName="FormItem";const FormLabel=reactExports.forwardRef(({className,...props},ref)=>{const{error,formItemId}=useFormField();return jsxRuntimeExports.jsx(Label,{ref,className:cn(error&&"text-destructive",className),htmlFor:formItemId,...props})});FormLabel.displayName="FormLabel";const FormControl=reactExports.forwardRef(({...props},ref)=>{const{error,formItemId,formDescriptionId,formMessageId}=useFormField();return jsxRuntimeExports.jsx(Slot,{ref,id:formItemId,"aria-describedby":error?`${formDescriptionId} ${formMessageId}`:`${formDescriptionId}`,"aria-invalid":!!error,...props})});FormControl.displayName="FormControl";const FormDescription=reactExports.forwardRef(({className,...props},ref)=>{const{formDescriptionId}=useFormField();return jsxRuntimeExports.jsx("p",{ref,id:formDescriptionId,className:cn("text-[0.8rem] text-muted-foreground",className),...props})});FormDescription.displayName="FormDescription";const FormMessage=reactExports.forwardRef(({className,children,...props},ref)=>{const{error,formMessageId}=useFormField(),body=error?String(error?.message??""):children;return body?jsxRuntimeExports.jsx("p",{ref,id:formMessageId,className:cn("text-[0.8rem] font-medium text-destructive",className),...props,children:body}):null});FormMessage.displayName="FormMessage";const KABUPATEN_DATA=[{id:"cianjur",name:"Kabupaten Cianjur",kecamatan:["Agrabinta","Bojongpicung","Campaka","Campakamulya","Cianjur","Cibeber","Cibinong","Cidaun","Cijati","Cikadu","Cikalongkulon","Cilaku","Cipanas","Ciranjang","Cugenang","Gekbrong","Haurwangi","Kadupandak","Karangtengah","Leles","Mande","Naringgul","Pacet","Pagelaran","Pasirkuda","Sindangbarang","Sukaluyu","Sukanagara","Sukaresmi","Takokak","Tanggeung","Warungkondang"]},{id:"sukabumi",name:"Kabupaten Sukabumi",kecamatan:["Cicurug","Cidahu","Cidolog","Ciemas","Cikakak","Cikembar","Cikidang","Ciracap","Cisolok","Cisaat","Gegerbitung","Jampang Kulon","Jampang Tengah","Kabandungan","Kalapanunggal","Lengkong","Nyalindung","Pabuaran","Palabuhanratu","Parung Kuda","Purabaya","Sagaranten","Simpenan","Sukabumi","Sukaraja","Warungkiara"]},{id:"bandung",name:"Kabupaten Bandung",kecamatan:["Arjasari","Baleendah","Banjaran","Bojongsoang","Cangkuang","Cicalengka","Cikancung","Cilengkrang","Cileunyi","Cimaung","Cimenyan","Ciparay","Ciwidey","Dayeuhkolot","Ibun","Katapang","Kertasari","Kutawaringin","Majalaya","Margaasih","Margahayu","Nagreg","Pacet","Pameungpeuk","Pangalengan","Paseh","Pasirjambu","Rancabali","Rancaekek","Solokanjeruk","Soreang"]}];function getKecamatanByKabupaten(kabupatenId){return KABUPATEN_DATA.find(k=>k.id===kabupatenId)?.kecamatan||[]}export{Form as F,KABUPATEN_DATA as K,a,FormField as b,FormItem as c,FormLabel as d,FormControl as e,FormDescription as f,getKecamatanByKabupaten as g,FormMessage as h,boolean as i,object as o,string as s,useForm as u};
